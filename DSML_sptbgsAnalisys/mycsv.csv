Column1;Column2
"        public String getFullName() {
            return className + ""."" + name;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Descriptor that = (Descriptor) o;
            return Objects.equals(name, that.name) &&
                Objects.equals(className, that.className) &&
";EQ_UNUSUAL
"    public NamedDomainObjectContainer<ElasticsearchNode> getNodes() {
        return nodes;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ElasticsearchCluster that = (ElasticsearchCluster) o;
        return Objects.equals(clusterName, that.clusterName) &&
            Objects.equals(path, that.path);
";EQ_UNUSUAL
"            this
        );
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        ElasticsearchNode that = (ElasticsearchNode) o;
        return Objects.equals(name, that.name) &&
            Objects.equals(path, that.path);
";EQ_UNUSUAL
"
    LazyFileOutputStream(File file) {
        // use an initial dummy delegate to avoid doing a conditional on every write
        this.delegate = new OutputStream() {
            private void bootstrap() throws IOException {
                file.getParentFile().mkdirs();
                delegate = new FileOutputStream(file);
            }
            @Override
            public void write(int b) throws IOException {
                bootstrap();
";RV_RETURN_VALUE_IGNORED_BAD_PRACTICE
"null
null
null
null
null
null
null
null
null
null
null
";EQ_UNUSUAL
"            versions.put(property, props.getProperty(property));
        }
    }

    private static Properties getVersionProperties() {
        Properties props = new Properties();
        InputStream propsStream = VersionProperties.class.getResourceAsStream(""/version.properties"");
        if (propsStream == null) {
            throw new IllegalStateException(""/version.properties resource missing"");
        }
        try {
";OBL_UNSATISFIED_OBLIGATION
"
    }

    @SuppressForbidden(reason = ""system out is ok for a command line tool"")
    private void runBulkIndexBenchmark(String[] args) throws Exception {
        if (args.length != 7) {
            System.err.println(
                ""usage: 'bulk' benchmarkTargetHostIp indexFilePath indexName typeName numberOfDocuments bulkSize"");
            System.exit(1);
        }
        String benchmarkTargetHost = args[1];
";ICAST_IDIV_CAST_TO_DOUBLE
"        return failedAttempts;
    }

    @Override
    public int compareTo(DeadHostState other) {
        if (timeSupplier != other.timeSupplier) {
            throw new IllegalArgumentException(""can't compare DeadHostStates holding different time suppliers as they may "" +
                ""be based on different clocks"");
        }
        return Long.compare(deadUntilNanos, other.deadUntilNanos);
    }
";EQ_COMPARETO_USE_OBJECT_EQUALS
"            if (ingest) result.append('i');
            return result.toString();
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null || obj.getClass() != getClass()) {
                return false;
            }
            Roles other = (Roles) obj;
            return masterEligible == other.masterEligible
";EQ_UNUSUAL
"
        Request other = (Request) obj;
        return method.equals(other.method)
                && endpoint.equals(other.endpoint)
                && parameters.equals(other.parameters)
                && Objects.equals(entity, other.entity)
                && options.equals(other.options);
    }

    @Override
    public int hashCode() {
";EQ_UNUSUAL
"        ReqHeader(String name, String value) {
            super(name, value);
        }

        @Override
        public boolean equals(Object other) {
            if (this == other) {
                return true;
            }
            if (other instanceof ReqHeader) {
                Header otherHeader = (Header) other;
";EQ_UNUSUAL
"        public String toString() {
            return node.toString();
        }

        @Override
        public int compareTo(DeadNode rhs) {
            return deadness.compareTo(rhs.deadness);
        }
    }

    /**
";EQ_COMPARETO_USE_OBJECT_EQUALS
"
        static final ConstructingObjectParser<Map.Entry<Long, Tuple<Integer, ElasticsearchException>>, Void> READ_EXCEPTIONS_ENTRY_PARSER =
            new ConstructingObjectParser<>(
                ""shard-follow-stats-read-exceptions-entry"",
                true,
                args -> new AbstractMap.SimpleEntry<>((long) args[0], Tuple.tuple((Integer) args[1], (ElasticsearchException)args[2])));

        static {
            PARSER.declareString(ConstructingObjectParser.constructorArg(), LEADER_CLUSTER);
            PARSER.declareString(ConstructingObjectParser.constructorArg(), LEADER_INDEX);
            PARSER.declareString(ConstructingObjectParser.constructorArg(), FOLLOWER_INDEX);
";BX_UNBOXING_IMMEDIATELY_REBOXED
"        return PARSER.parse(parser, null);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
";EQ_DOESNT_OVERRIDE_EQUALS
"        private final int failed;

        /**
         * The number of shards on which a request failed to be executed against.
         *
         * @return the number of failed shards
         */
        public int failed() {
            return failed;
        }

";EI_EXPOSE_REP
"null
null
null
null
null
null
null
null
null
null
null
";EI_EXPOSE_REP2
"    public void setFields(String... fields) {
        this.fields = fields;
    }

    public String[] getFields() {
        return fields;
    }

    /**
     * Sets whether to request term positions
     */
";EI_EXPOSE_REP
"        return termVectorList;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (!(obj instanceof TermVectorsResponse)) return false;
        TermVectorsResponse other = (TermVectorsResponse) obj;
        return index.equals(other.index)
            && Objects.equals(id, other.id)
            && docVersion == other.docVersion
";SA_FIELD_SELF_COMPARISON
"            String name,
            TriFunction<Boolean, List<TaskOperationFailure>, List<? extends ElasticsearchException>, T> ctor,
            String ackFieldName) {

        ConstructingObjectParser<T, Void> parser = new ConstructingObjectParser<>(name, true,
                args -> ctor.apply((boolean) args[0], (List<TaskOperationFailure>) args[1], (List<ElasticsearchException>) args[2]));
        parser.declareBoolean(constructorArg(), new ParseField(ackFieldName));
        parser.declareObjectArray(optionalConstructorArg(), (p, c) -> TaskOperationFailure.fromXContent(p), TASK_FAILURES);
        parser.declareObjectArray(optionalConstructorArg(), (p, c) -> ElasticsearchException.fromXContent(p), NODE_FAILURES);
        return parser;
    }
";BX_UNBOXING_IMMEDIATELY_REBOXED
"    public IndexerState getIndexerState() {
        return indexerState;
    }

    public DataFrameTransformTaskState getTaskState() {
        return taskState;
    }

    @Nullable
    public Map<String, Object> getPosition() {
        return currentPosition;
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        this.index = index;
        this.queryConfig = queryConfig;
    }

    public String[] getIndex() {
        return index;
    }

    public QueryConfig getQueryConfig() {
        return queryConfig;
    }
";EI_EXPOSE_REP
"                ObjectParser.ValueType.STRING_OR_NULL);
    }

    public static TimeSyncConfig fromXContent(XContentParser parser) {
        return PARSER.apply(parser, null);
    }

    public TimeSyncConfig(String field, TimeValue delay) {
        this.field = field;
        this.delay = delay;
    }
";NP_NULL_PARAM_DEREF_NONVIRTUAL
"            throw new IllegalArgumentException(""IndicesOptions must not be null"");
        }
        this.indicesOptions = indicesOptions;
        return this;
    }

    /**
     * The document types to execute the explore against. Defaults to be executed against
     * all types.
     *
     * @deprecated Types are in the process of being removed. Instead of using a type, prefer to
";EI_EXPOSE_REP
" */
public class GraphExploreResponse implements ToXContentObject {

    private long tookInMillis;
    private boolean timedOut = false;
    private ShardOperationFailedException[] shardFailures = ShardSearchFailure.EMPTY_ARRAY;
    private Map<VertexId, Vertex> vertices;
    private Map<ConnectionId, Connection> connections;
    private boolean returnDetailedInfo;
    static final String RETURN_DETAILED_INFO_PARAM = ""returnDetailedInfo"";

";EI_EXPOSE_REP2
"        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        AllocateAction other = (AllocateAction) obj;
        return Objects.equals(numberOfReplicas, other.numberOfReplicas) &&
            Objects.equals(include, other.include) &&
            Objects.equals(exclude, other.exclude) &&
            Objects.equals(require, other.require);
    }

";DLS_DEAD_LOCAL_STORE
"        }
        this.indices = indices;
    }

    public String[] getIndices() {
        return indices;
    }

    public ExplainLifecycleRequest indicesOptions(IndicesOptions indicesOptions) {
        this.indicesOptions = indicesOptions;
        return this;
";EI_EXPOSE_REP
"            this.policyNames = policyNames;
        }
    }

    public String[] getPolicyNames() {
        return policyNames;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
";EI_EXPOSE_REP
"    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        return true;
    }

";DLS_DEAD_LOCAL_STORE
"
    @Override
    public int hashCode() {
        return recoveryPriority != null ? recoveryPriority.hashCode() : 0;
    }

    @Override
    public String toString() {
        return Strings.toString(this);
    }

";DLS_DEAD_LOCAL_STORE
"
    /**
     * Returns the text to be analyzed
     */
    public String[] text() {
        return this.text;
    }

    /**
     * Returns the named analyzer used for analysis, if defined
     */
";EI_EXPOSE_REP
"        public String getName() {
            return name;
        }

        public String[] getTexts() {
            return texts;
        }

        @SuppressWarnings(""unchecked"")
        private static final ConstructingObjectParser<CharFilteredText, Void> PARSER = new ConstructingObjectParser<>(""char_filtered_text"",
            true, args -> new CharFilteredText((String) args[0], ((List<String>) args[1]).toArray(new String[0])));
";EI_EXPOSE_REP
"
    /**
     * Creates a new freeze index request
     * @param indices the index to freeze
     */
    public FreezeIndexRequest(String... indices) {
        this.indices = Objects.requireNonNull(indices);
    }

    /**
     * Returns the indices to freeze
";EI_EXPOSE_REP2
"        this.indicesOptions = indicesOptions;
        return this;
    }

    public String[] indices() {
        return indices;
    }

    public IndicesOptions indicesOptions() {
        return indicesOptions;
    }
";EI_EXPOSE_REP
"
    /**
     * The indices into which the mappings will be put.
     */
    public String[] indices() {
        return indices;
    }

    public IndicesOptions indicesOptions() {
        return indicesOptions;
    }
";EI_EXPOSE_REP
"            this.defaultSettings = defaultSettings;
        }
    }

    public String[] getIndices() {
        return indices;
    }

    public Map<String, MappingMetaData> getMappings() {
        return mappings;
    }
";EI_EXPOSE_REP
"    }

    public void setMasterNodeTimeout(@Nullable TimeValue masterNodeTimeout) {
        this.masterNodeTimeout = masterNodeTimeout;
    }

    public void setMasterNodeTimeout(String masterNodeTimeout) {
        final TimeValue timeValue = TimeValue.parseTimeValue(masterNodeTimeout, getClass().getSimpleName() + "".masterNodeTimeout"");
        setMasterNodeTimeout(timeValue);
    }

";EI_EXPOSE_REP
"        this.indicesOptions = indicesOptions;
        return this;
    }

    public String[] indices() {
        return indices;
    }

    public IndicesOptions indicesOptions() {
        return indicesOptions;
    }
";EI_EXPOSE_REP
"    /**
     * The indices into which the mappings will be put.
     */
    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public IndicesOptions indicesOptions() {
        return indicesOptions;
";EI_EXPOSE_REP
"
    /**
     * Creates a new reload analyzers request
     * @param indices the index for which to reload analyzers
     */
    public ReloadAnalyzersRequest(String... indices) {
        this.indices = Objects.requireNonNull(indices);
    }

    /**
     * Returns the indices
";EI_EXPOSE_REP2
"
    /**
     * Creates a new unfreeze index request
     * @param indices the index to unfreeze
     */
    public UnfreezeIndexRequest(String... indices) {
        this.indices = Objects.requireNonNull(indices);
    }

    /**
     * Returns the indices to unfreeze
";EI_EXPOSE_REP2
"    public String getDescription() {
        return description;
    }

    public Date getStartTime() {
        return startTime;
    }

    public Date getEndTime() {
        return endTime;
    }
";EI_EXPOSE_REP
"null
null
null
null
null
null
null
null
null
null
null
";EQ_UNUSUAL
"        this.index = Objects.requireNonNull(index);
        this.queryConfig = queryConfig;
    }

    public String[] getIndex() {
        return index;
    }

    public QueryConfig getQueryConfig() {
        return queryConfig;
    }
";EI_EXPOSE_REP
"    public String getEvaluationName() {
        return evaluationName;
    }

    public List<EvaluationMetric.Result> getMetrics() {
        return metrics.values().stream().collect(Collectors.toList());
    }

    @SuppressWarnings(""unchecked"")
    public <T extends EvaluationMetric.Result> T getMetricByName(String metricName) {
        Objects.requireNonNull(metricName);
";NP_UNWRITTEN_FIELD
"        return Objects.hash(jobId, calcInterim, start, end, advanceTime, skipTime);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }

        if (obj == null || getClass() != obj.getClass()) {
            return false;
";RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN
"    }

    private final boolean flushed;
    private final Date lastFinalizedBucketEnd;

    public FlushJobResponse(boolean flushed, @Nullable Date lastFinalizedBucketEnd) {
        this.flushed = flushed;
        this.lastFinalizedBucketEnd = lastFinalizedBucketEnd;
    }

    /**
";EI_EXPOSE_REP2
"null
null
null
null
null
null
null
null
null
null
null
";EI_EXPOSE_REP2
"    private Date latestRecordTimeStamp;
    private Date lastDataTimeStamp;
    private Date latestEmptyBucketTimeStamp;
    private Date latestSparseBucketTimeStamp;

    public DataCounts(String jobId, long processedRecordCount, long processedFieldCount, long inputBytes,
                      long inputFieldCount, long invalidDateCount, long missingFieldCount, long outOfOrderTimeStampCount,
                      long emptyBucketCount, long sparseBucketCount, long bucketCount,
                      Date earliestRecordTimeStamp, Date latestRecordTimeStamp, Date lastDataTimeStamp,
                      Date latestEmptyBucketTimeStamp, Date latestSparseBucketTimeStamp) {
        this.jobId = jobId;
";EI_EXPOSE_REP2
"            this.memoryStatus = memoryStatus;
            return this;
        }

        public Builder setTimestamp(Date timestamp) {
            this.timestamp = timestamp;
            return this;
        }

        public Builder setLogTime(Date logTime) {
            this.logTime = logTime;
";EI_EXPOSE_REP2
"null
null
null
null
null
null
null
null
null
null
null
";EI_EXPOSE_REP2
"
    private final String jobId;
    private final Date timestamp;
    private final String quantileState;

    public Quantiles(String jobId, Date timestamp, String quantileState) {
        this.jobId = jobId;
        this.timestamp = Objects.requireNonNull(timestamp);
        this.quantileState = Objects.requireNonNull(quantileState);
    }

";EI_EXPOSE_REP2
"
    void setInitialRecordScore(double initialRecordScore) {
        this.initialRecordScore = initialRecordScore;
    }

    public Date getTimestamp() {
        return timestamp;
    }

    /**
     * Bucketspan expressed in seconds
";WMI_WRONG_MAP_ITERATOR
"    public List<BucketInfluencer> getBucketInfluencers() {
        return bucketInfluencers;
    }

    void setBucketInfluencers(List<BucketInfluencer> bucketInfluencers) {
        this.bucketInfluencers = Collections.unmodifiableList(bucketInfluencers);
    }

    public List<String> getScheduledEvents() {
        return scheduledEvents;
    }
";EI_EXPOSE_REP
"    public boolean isInterim() {
        return isInterim;
    }

    public Date getTimestamp() {
        return timestamp;
    }

    @Override
    public int hashCode() {
        return Objects.hash(influenceField, initialAnomalyScore, anomalyScore, rawAnomalyScore, probability, isInterim, timestamp, jobId,
";EI_EXPOSE_REP
"    void setInfluencerScore(double score) {
        influencerScore = score;
    }

    public boolean isInterim() {
        return isInterim;
    }

    void setInterim(boolean value) {
        isInterim = value;
    }
";EI_EXPOSE_REP
"    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject();
        builder.timeField(Result.TIMESTAMP.getPreferredName(), Result.TIMESTAMP.getPreferredName() + ""_string"", timestamp.getTime());
        builder.field(BUCKET_SPAN.getPreferredName(), bucketSpan);
        builder.field(OVERALL_SCORE.getPreferredName(), overallScore);
        builder.field(JOBS.getPreferredName(), jobs);
        builder.field(Result.IS_INTERIM.getPreferredName(), isInterim);
        builder.field(Result.RESULT_TYPE.getPreferredName(), RESULT_TYPE_VALUE);
        builder.endObject();
        return builder;
";EI_EXPOSE_REP
"
    public GetRollupIndexCapsRequest(final String... indices) {
        this(indices, IndicesOptions.STRICT_EXPAND_OPEN_FORBID_CLOSED);
    }

    public GetRollupIndexCapsRequest(final String[] indices, final IndicesOptions options) {
        if (indices == null || indices.length == 0) {
            throw new IllegalArgumentException(""[indices] must not be null or empty"");
        }
        for (String index : indices) {
            if (Strings.isNullOrEmpty(index)) {
";EI_EXPOSE_REP2
"    }

    private final long interval;
    private final String[] fields;

    public HistogramGroupConfig(final long interval, final String... fields) {
        this.interval = interval;
        this.fields = fields;
    }

    @Override
";EI_EXPOSE_REP2
"        this.pageSize = pageSize;
    }

    @Override
    public Optional<ValidationException> validate() {
        final ValidationException validationException = new ValidationException();
        if (id == null || id.isEmpty()) {
            validationException.addValidationError(""Id must be a non-null, non-empty string"");
        }
        if (indexPattern == null || indexPattern.isEmpty()) {
            validationException.addValidationError(""Index pattern must be a non-null, non-empty string"");
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    /**
     * @return the names of the fields. Never {@code null}.
     */
    public String[] getFields() {
        return fields;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject();
";EI_EXPOSE_REP
"    public String getUsername() {
        return username;
    }

    public char[] getPassword() {
        return password;
    }

    public RefreshPolicy getRefreshPolicy() {
        return refreshPolicy;
    }
";EI_EXPOSE_REP
"
    /**
     * @return an array of role names that will have the cache evicted or <code>null</code> if all
     */
    public String[] names() {
        return names;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
";EI_EXPOSE_REP
"     * <li>{@link #refreshTokenGrant(String)}</li>
     * <li>{@link #clientCredentialsGrant()}</li>
     * <li>{@link #kerberosGrant(char[])}</li>
     * </ul>
     */
    public CreateTokenRequest(String grantType, @Nullable String scope, @Nullable String username, @Nullable char[] password,
                              @Nullable String refreshToken, @Nullable char[] kerberosTicket) {
        if (Strings.isNullOrEmpty(grantType)) {
            throw new IllegalArgumentException(""grant_type is required"");
        }
        this.grantType = grantType;
";EI_EXPOSE_REP2
"     *
     * @param application   the name of the application for which the privileges will be deleted
     * @param privileges    the privileges to delete
     * @param refreshPolicy the refresh policy {@link RefreshPolicy} for the request, defaults to {@link RefreshPolicy#getDefault()}
     */
    public DeletePrivilegesRequest(String application, String[] privileges, @Nullable RefreshPolicy refreshPolicy) {
        if (Strings.hasText(application) == false) {
            throw new IllegalArgumentException(""application name is required"");
        }
        if (CollectionUtils.isEmpty(privileges)) {
            throw new IllegalArgumentException(""privileges are required"");
";EI_EXPOSE_REP2
"    }

    public static GetApiKeyResponse emptyResponse() {
        return new GetApiKeyResponse(Collections.emptyList());
    }

    public List<ApiKey> getApiKeyInfos() {
        return foundApiKeysInfo;
    }

    @Override
";EI_EXPOSE_REP
"
    /**
     * @return an array of privilege names to return or null if all should be returned
     */
    public String[] getPrivilegeNames() {
        return privilegeNames;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
";EI_EXPOSE_REP
"
import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

/**
 * Get role mappings response
 */
public final class GetRoleMappingsResponse {

";EI_EXPOSE_REP
"import org.elasticsearch.client.security.user.privileges.Role;
import org.elasticsearch.common.collect.Tuple;
import org.elasticsearch.common.xcontent.XContentParser;
import org.elasticsearch.common.xcontent.XContentParserUtils;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
";EI_EXPOSE_REP
"import org.elasticsearch.common.xcontent.XContentParserUtils;

import java.io.IOException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.function.Function;
import java.util.stream.Collectors;
";EI_EXPOSE_REP
"            .field(""index"", indexPrivileges)
            .field(""application"", applicationPrivileges)
            .endObject();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
";EI_EXPOSE_REP
"     * @throws IllegalArgumentException if the response did not include a value for the specified index and privilege name pair.
     *                                  The response only includes values for indices and privileges that were
     *                                  {@link HasPrivilegesRequest#getIndexPrivileges() included in the request}.
     */
    public boolean hasIndexPrivilege(String indexName, String privilegeName) {
        Map<String, Boolean> indexPrivileges = this.indexPrivileges.get(indexName);
        if (indexPrivileges == null) {
            throw new IllegalArgumentException(""No privileges for index ["" + indexName + ""] were included in this response"");
        }
        Boolean has = indexPrivileges.get(privilegeName);
        if (has == null) {
";WMI_WRONG_MAP_ITERATOR
"        return applicationPrivilegesCreatedOrUpdated.get(applicationName).get(privilegeName);
    }

    @SuppressWarnings(""unchecked"")
    public static PutPrivilegesResponse fromXContent(final XContentParser parser) throws IOException {
        final Map<String, Map<String, Boolean>> applicationPrivilegesCreatedOrUpdated = new HashMap<>();
        XContentParser.Token token = parser.currentToken();
        if (token == null) {
            token = parser.nextToken();
        }
        final Map<String, Object> appNameToPrivStatus = parser.map();
";WMI_WRONG_MAP_ITERATOR
"    public User getUser() {
        return user;
    }

    public @Nullable char[] getPassword() {
        return password;
    }

    public boolean isEnabled() {
        return enabled;
    }
";EI_EXPOSE_REP
"        return result;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject();
        builder.startObject(""field"");
        builder.startArray(this.field);
        for (Object value : values) {
            builder.value(value);
        }
";NP_UNWRITTEN_FIELD
"        return this.privileges;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || this.getClass() != o.getClass()) {
            return false;
        }
";NP_UNWRITTEN_FIELD
"        }
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject();
        for (final Map.Entry<String, List<GlobalOperationPrivilege>> privilegesByCategory : this.privilegesByCategoryMap.entrySet()) {
            builder.startObject(privilegesByCategory.getKey());
            for (final GlobalOperationPrivilege privilege : privilegesByCategory.getValue()) {
                builder.field(privilege.getOperation(), privilege.getRaw());
            }
";NP_UNWRITTEN_FIELD
"        return query.isEmpty() == false;
    }

    @Override
    public boolean isUsingFieldLevelSecurity() {
        return fieldSecurity.stream().anyMatch(FieldSecurity::isUsingFieldLevelSecurity);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
";NP_UNWRITTEN_FIELD
"        public static ShardCounts fromXContent(XContentParser parser) throws IOException {
            return PARSER.parse(parser, null);
        }

        public boolean equals(ShardCounts other) {
            if (other != null) {
                return
                    other.total == this.total &&
                    other.successful == this.successful &&
                    other.failed == this.failed;
            } else {
";HE_EQUALS_USE_HASHCODE
"    /**
     * @return The IDs of the actions to be acked. If omitted,
     * all actions for the given watch will be acknowledged.
     */
    public String[] getActionIds() {
        return actionIds;
    }

    @Override
    public String toString() {
        StringBuilder sb = new StringBuilder(""ack ["").append(watchId).append(""]"");
";EI_EXPOSE_REP
"    }

    @Override
    public int hashCode() {
        return Objects.hash(ackStatus, lastExecution, lastSuccessfulExecution, lastThrottle);
    }

    public static ActionStatus parse(String actionId, XContentParser parser) throws IOException {
        AckStatus ackStatus = null;
        Execution lastExecution = null;
        Execution lastSuccessfulExecution = null;
";SF_SWITCH_NO_DEFAULT
"        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        QueuedWatch that = (QueuedWatch) o;
        return Objects.equals(watchId, that.watchId) &&
            Objects.equals(watchRecordId, that.watchRecordId) &&
            Objects.equals(triggeredTime, that.triggeredTime) &&
            Objects.equals(executionTime, that.executionTime);
    }

    @Override
    public int hashCode() {
";EQ_UNUSUAL
"null
null
null
null
null
null
null
null
null
null
null
";SF_SWITCH_NO_DEFAULT
"        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        WatchExecutionSnapshot that = (WatchExecutionSnapshot) o;
        return Objects.equals(watchId, that.watchId) &&
            Objects.equals(watchRecordId, that.watchRecordId) &&
            Objects.equals(triggeredTime, that.triggeredTime) &&
            Objects.equals(executionTime, that.executionTime) &&
            phase == that.phase &&
            Arrays.equals(executedActions, that.executedActions) &&
            Arrays.equals(executionStackTrace, that.executionStackTrace);
    }
";EQ_UNUSUAL
"        public int hashCode() {
            return Objects.hash(key, value);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
" * A cli tool for managing secrets in the elasticsearch keystore.
 */
public class KeyStoreCli extends LoggingAwareMultiCommand {

    private KeyStoreCli() {
        super(""A tool for managing settings stored in the elasticsearch keystore"");
        subcommands.put(""create"", new CreateKeyStoreCommand());
        subcommands.put(""list"", new ListKeyStoreCommand());
        subcommands.put(""add"", new AddStringKeyStoreCommand());
        subcommands.put(""add-file"", new AddFileKeyStoreCommand());
        subcommands.put(""remove"", new RemoveSettingKeyStoreCommand());
";NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD
"     *
     * @param userDefinedJvmOptions A list of JVM options that have been defined by the user.
     * @return A list of additional JVM options to set.
     */
    static List<String> choose(final List<String> userDefinedJvmOptions) throws InterruptedException, IOException {
        final List<String> ergonomicChoices = new ArrayList<>();
        final Map<String, Optional<String>> finalJvmOptions = finalJvmOptions(userDefinedJvmOptions);
        final long heapSize = extractHeapSize(finalJvmOptions);
        final Map<String, String> systemProperties = extractSystemProperties(userDefinedJvmOptions);
        if (systemProperties.containsKey(""io.netty.allocator.type"") == false) {
            if (heapSize <= 1 << 30) {
";DLS_DEAD_LOCAL_STORE
"public class PluginCli extends LoggingAwareMultiCommand {

    private final Collection<Command> commands;

    private PluginCli() {
        super(""A tool for managing installed elasticsearch plugins"");
        subcommands.put(""list"", new ListPluginsCommand());
        subcommands.put(""install"", new InstallPluginCommand());
        subcommands.put(""remove"", new RemovePluginCommand());
        commands = Collections.unmodifiableCollection(subcommands.values());
    }
";NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD
"            super(System.lineSeparator());
        }

        @SuppressForbidden(reason = ""Writer for System.out"")
        private static PrintWriter newWriter() {
            return new PrintWriter(System.out);
        }

        @Override
        public PrintWriter getWriter() {
            return WRITER;
";DM_DEFAULT_ENCODING
"     * @return array of URLs
     * @throws IllegalStateException if the classpath contains empty elements
     */
    @SuppressForbidden(reason = ""resolves against CWD because that is how classpaths work"")
    static Set<URL> parseClassPath(String classPath) {
        String pathSeparator = System.getProperty(""path.separator"");
        String fileSeparator = System.getProperty(""file.separator"");
        String elements[] = classPath.split(pathSeparator);
        Set<URL> urlElements = new LinkedHashSet<>(); // order is already lost, but some filesystems have it
        for (String element : elements) {
            // Technically empty classpath element behaves like CWD.
";DMI_COLLECTION_OF_URLS
"            return order;
        }

        @Override
        public int compareTo(AppendValue o) {
            return Integer.compare(this.order, o.getOrder());
        }
    }

    /**
     * A result that needs to be converted to a key/value reference
";EQ_COMPARETO_USE_OBJECT_EQUALS
"
    public Line(double[] lats, double[] lons) {
        this(lats, lons, null);
    }

    public Line(double[] lats, double[] lons, double[] alts) {
        this.lats = lats;
        this.lons = lons;
        this.alts = alts;
        if (lats == null) {
            throw new IllegalArgumentException(""lats must not be null"");
";EI_EXPOSE_REP2
"     * @param dx      delta of the first grid coordinate (must be -1, 0 or +1)
     * @param dy      delta of the second grid coordinate (must be -1, 0 or +1)
     * @return geohash of the defined cell
     */
    public static final String getNeighbor(String geohash, int level, int dx, int dy) {
        int cell = BASE_32_STRING.indexOf(geohash.charAt(level -1));

        // Decoding the Geohash bit pattern to determine grid coordinates
        int x0 = cell & 1;  // first bit of x
        int y0 = cell & 2;  // first bit of y
        int x1 = cell & 4;  // second bit of x
";IM_BAD_CHECK_FOR_ODD
"    private final ByteBuffer[] buffers;
    private final int[] offsets;
    private final int length;
    private int internalIndex;

    public FlushOperation(ByteBuffer[] buffers, BiConsumer<Void, Exception> listener) {
        this.listener = listener;
        this.buffers = buffers;
        this.offsets = new int[buffers.length];
        int offset = 0;
        for (int i = 0; i < buffers.length; i++) {
";EI_EXPOSE_REP2
"
    private final SocketChannelContext channelContext;
    private final ByteBuffer[] buffers;

    public FlushReadyWrite(SocketChannelContext channelContext, ByteBuffer[] buffers, BiConsumer<Void, Exception> listener) {
        super(buffers, listener);
        this.channelContext = channelContext;
        this.buffers = buffers;
    }

    @Override
";EI_EXPOSE_REP2
"            ExceptionsHelper.rethrowAndSuppress(closingExceptions);
        }
    }

    public void ensureCapacity(long requiredCapacity) {
        if (isClosed.get()) {
            throw new IllegalStateException(""Cannot allocate new pages if the buffer is closed."");
        }
        if (capacity < requiredCapacity) {
            int numPages = numPages(requiredCapacity + offset);
            int pagesToAdd = numPages - pages.size();
";ICAST_INTEGER_MULTIPLY_CAST_TO_LONG
"     * @param selectorThreadFactory factory to create non-acceptor selector threads
     * @param selectorCount the number of non-acceptor selectors to be created
     * @param eventHandlerFunction function for creating event handlers
     * @throws IOException occurs if there is a problem while opening a java.nio.Selector
     */
    public NioSelectorGroup(ThreadFactory acceptorThreadFactory, int dedicatedAcceptorCount, ThreadFactory selectorThreadFactory,
                            int selectorCount, Function<Supplier<NioSelector>, EventHandler> eventHandlerFunction) throws IOException {
        dedicatedAcceptors = new ArrayList<>(dedicatedAcceptorCount);
        selectors = new ArrayList<>(selectorCount);

        try {
";REC_CATCH_EXCEPTION
"null
null
null
null
null
null
null
null
null
null
null
";EQ_UNUSUAL
"     * Creates a new security manager with the specified list of regular expressions as the those that class names will be tested against to
     * check whether or not a class can exit or halt the virtual machine.
     *
     * @param classesThatCanExit the list of classes that can exit or halt the virtual machine
     */
    public SecureSM(final String[] classesThatCanExit) {
        this.classesThatCanExit = classesThatCanExit;
    }

    /**
     * Creates a new security manager with a standard set of test packages being the only packages that can exit or halt the virtual
";EI_EXPOSE_REP2
"    /**
     * @return an array of the names for the {@link ParseField} which are
     *         deprecated.
     */
    public String[] getDeprecatedNames() {
        return deprecatedNames;
    }

    public static class CommonFields {
        public static final ParseField FIELD = new ParseField(""field"");
        public static final ParseField FIELDS = new ParseField(""fields"");
";EI_EXPOSE_REP
"null
null
null
null
null
null
null
null
null
null
null
";DM_BOXED_PRIMITIVE_FOR_PARSING
"        this.mergeCovariance(other, deltas);
    }

    /** Merges two covariance matrices */
    private void mergeCovariance(final RunningStats other, final Map<String, Double> deltas) {
        final double countA = docCount - other.docCount;
        double f, dR, newVal;
        for (Map.Entry<String, Double> fs : other.means.entrySet()) {
            final String fieldName = fs.getKey();
            // merge covariances of two sets
            f = countA * other.docCount / this.docCount;
";WMI_WRONG_MAP_ITERATOR
"        }
        return needsScores;
    }

    public String[] fieldNames() {
        return this.names;
    }
}
null
null
null
";EI_EXPOSE_REP
"                                                                AggregatorFactory parent,
                                                                AggregatorFactories.Builder subFactoriesBuilder) throws IOException;

    public ValuesSourceConfig<VS> config(SearchContext context, String field, Script script) {

        ValueType valueType = this.valueType != null ? this.valueType : targetValueType;

        if (field == null) {
            if (script == null) {
                ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(ValuesSourceType.ANY);
                return config.format(resolveFormat(null, valueType));
";NP_LOAD_OF_KNOWN_NULL_VALUE
"            throw new RuntimeException(""Invalid escaped char ["" + s + ""]"");
        }
    }

    @Override
    public Tokenizer create() {
        return new CharTokenizer() {
            @Override
            protected boolean isTokenChar(int c) {
                if (tokenizeOnSpace && Character.isWhitespace(c)) {
                    return false;
";IL_INFINITE_RECURSIVE_LOOP
"        super(indexSettings, settings, name);
        maxTokenLength = settings.getAsInt(""max_token_length"", StandardAnalyzer.DEFAULT_MAX_TOKEN_LENGTH);
    }

    @Override
    public Tokenizer create() {
        ClassicTokenizer tokenizer = new ClassicTokenizer();
        tokenizer.setMaxTokenLength(maxTokenLength);
        return tokenizer;
    }
}
";IL_INFINITE_RECURSIVE_LOOP
"        this.maxGram = settings.getAsInt(""max_gram"", NGramTokenizer.DEFAULT_MAX_NGRAM_SIZE);
        this.matcher = parseTokenChars(settings.getAsList(""token_chars""));
    }

    @Override
    public Tokenizer create() {
        if (matcher == null) {
            return new EdgeNGramTokenizer(minGram, maxGram);
        } else {
            return new EdgeNGramTokenizer(minGram, maxGram) {
                @Override
";IL_INFINITE_RECURSIVE_LOOP
"        super(indexSettings, settings, name);
        bufferSize = settings.getAsInt(""buffer_size"", 256);
    }

    @Override
    public Tokenizer create() {
        return new KeywordTokenizer(bufferSize);
    }
}
null
null
";IL_INFINITE_RECURSIVE_LOOP
"
    // ancient unsupported option
    private static final String ENABLE_POS_INC_KEY = ""enable_position_increments"";

    LengthTokenFilterFactory(IndexSettings indexSettings, Environment environment, String name, Settings settings) {
        super(indexSettings, name, settings);
        min = settings.getAsInt(""min"", 0);
        max = settings.getAsInt(""max"", Integer.MAX_VALUE);
        if (settings.get(ENABLE_POS_INC_KEY) != null) {
            throw new IllegalArgumentException(ENABLE_POS_INC_KEY + "" is not supported anymore. Please fix your analysis chain"");
        }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    LetterTokenizerFactory(IndexSettings indexSettings, Environment environment, String name, Settings settings) {
        super(indexSettings, settings, name);
    }

    @Override
    public Tokenizer create() {
        return new LetterTokenizer();
    }
}
null
null
";IL_INFINITE_RECURSIVE_LOOP
"        }
        this.matcher = parseTokenChars(settings.getAsList(""token_chars""));
    }

    @Override
    public Tokenizer create() {
        if (matcher == null) {
            return new NGramTokenizer(minGram, maxGram);
        } else {
            return new NGramTokenizer(minGram, maxGram) {
                @Override
";IL_INFINITE_RECURSIVE_LOOP
"        this.skip = settings.getAsInt(""skip"", PathHierarchyTokenizer.DEFAULT_SKIP);
        this.reverse = settings.getAsBoolean(""reverse"", false);
    }

    @Override
    public Tokenizer create() {
        if (reverse) {
            return new ReversePathHierarchyTokenizer(bufferSize, delimiter, replacement, skip);
        }
        return new PathHierarchyTokenizer(bufferSize, delimiter, replacement, skip);
    }
";IL_INFINITE_RECURSIVE_LOOP
"    private final boolean preserveOriginal;
    private static final String PATTERNS_KEY = ""patterns"";
    private static final String PRESERVE_ORIG_KEY = ""preserve_original"";

    PatternCaptureGroupTokenFilterFactory(IndexSettings indexSettings, Environment environment, String name, Settings settings) {
        super(indexSettings, name, settings);
        List<String> regexes = settings.getAsList(PATTERNS_KEY, null, false);
        if (regexes == null) {
            throw new IllegalArgumentException(""required setting '"" + PATTERNS_KEY + ""' is missing for token filter ["" + name + ""]"");
        }
        patterns = new Pattern[regexes.size()];
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    private final Pattern pattern;
    private final String replacement;
    private final boolean all;

    public PatternReplaceTokenFilterFactory(IndexSettings indexSettings, Environment environment, String name, Settings settings) {
        super(indexSettings, name, settings);

        String sPattern = settings.get(""pattern"", null);
        if (sPattern == null) {
            throw new IllegalArgumentException(""pattern is missing for ["" + name + ""] token filter of type 'pattern_replace'"");
        }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    private final Pattern pattern;
    private final int group;

    PatternTokenizerFactory(IndexSettings indexSettings, Environment environment, String name, Settings settings) {
        super(indexSettings, settings, name);

        String sPattern = settings.get(""pattern"", ""\\W+"" /*PatternAnalyzer.NON_WORD_PATTERN*/);
        if (sPattern == null) {
            throw new IllegalArgumentException(""pattern is missing for ["" + name + ""] tokenizer of type 'pattern'"");
        }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    @Override
    public TokenFilterFactory getChainAwareTokenFilterFactory(TokenizerFactory tokenizer, List<CharFilterFactory> charFilters,
                                                              List<TokenFilterFactory> previousTokenFilters,
                                                              Function<String, TokenFilterFactory> allFilters) {
        List<TokenFilterFactory> filters = new ArrayList<>();
        List<TokenFilterFactory> existingChain = new ArrayList<>(previousTokenFilters);
        for (String filter : filterNames) {
            TokenFilterFactory tff = allFilters.apply(filter);
            if (tff == null) {
                throw new IllegalArgumentException(""ScriptedConditionTokenFilter ["" + name() +
";UC_USELESS_OBJECT
"
        pattern = settings.get(""pattern"", """");
    }

    @Override
    public Tokenizer create() {
        return new SimplePatternSplitTokenizer(pattern);
    }
}
null
null
";IL_INFINITE_RECURSIVE_LOOP
"
        pattern = settings.get(""pattern"", """");
    }

    @Override
    public Tokenizer create() {
        return new SimplePatternTokenizer(pattern);
    }
}
null
null
";IL_INFINITE_RECURSIVE_LOOP
"    ThaiTokenizerFactory(IndexSettings indexSettings, Environment environment, String name, Settings settings) {
        super(indexSettings, settings, name);
    }

    @Override
    public Tokenizer create() {
        return new ThaiTokenizer();
    }
}
null
null
";IL_INFINITE_RECURSIVE_LOOP
"public class TrimTokenFilterFactory extends AbstractTokenFilterFactory implements NormalizingTokenFilterFactory {

    private static final String UPDATE_OFFSETS_KEY = ""update_offsets"";

    TrimTokenFilterFactory(IndexSettings indexSettings, Environment env, String name, Settings settings) {
        super(indexSettings, name, settings);
        if (settings.get(UPDATE_OFFSETS_KEY) != null) {
            throw new IllegalArgumentException(UPDATE_OFFSETS_KEY +  "" is not supported anymore. Please fix your analysis chain"");
        }
    }

";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        super(indexSettings, settings, name);
        maxTokenLength = settings.getAsInt(""max_token_length"", StandardAnalyzer.DEFAULT_MAX_TOKEN_LENGTH);
    }

    @Override
    public Tokenizer create() {
        UAX29URLEmailTokenizer tokenizer = new UAX29URLEmailTokenizer();
        tokenizer.setMaxTokenLength(maxTokenLength);
        return tokenizer;
    }
}
";IL_INFINITE_RECURSIVE_LOOP
"        super(indexSettings, settings, name);
        maxTokenLength = settings.getAsInt(MAX_TOKEN_LENGTH, StandardAnalyzer.DEFAULT_MAX_TOKEN_LENGTH);
    }

    @Override
    public Tokenizer create() {
        return new WhitespaceTokenizer(TokenStream.DEFAULT_TOKEN_ATTRIBUTE_FACTORY, maxTokenLength);
    }
}
null
null
";IL_INFINITE_RECURSIVE_LOOP
"    public XLowerCaseTokenizerFactory(IndexSettings indexSettings, Environment environment, String name, Settings settings) {
        super(indexSettings, settings, name);
    }

    @Override
    public Tokenizer create() {
        return new XLowerCaseTokenizer();
    }
}
null
null
";IL_INFINITE_RECURSIVE_LOOP
"    @Override
    protected Collection<Class<? extends Plugin>> getPlugins() {
        return Collections.singleton(CommonAnalysisPlugin.class);
    }

    @Before
    public void setup() {
        Settings settings = Settings.builder()
            .put(""index.analysis.filter.shingle.type"", ""shingle"")
            .put(""index.analysis.filter.shingle.output_unigrams"", false)
            .put(""index.analysis.filter.shingle.min_size"", 2)
";NM_VERY_CONFUSING
"        this.ignoreMissing = ignoreMissing;
    }

    @Override
    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {
        String fieldValue = ingestDocument.getFieldValue(matchField, String.class, ignoreMissing);

        if (fieldValue == null && ignoreMissing) {
            return ingestDocument;
        } else if (fieldValue == null) {
            throw new IllegalArgumentException(""field ["" + matchField + ""] is null, cannot process it."");
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"                this.responseType = responseType;
            }

            //generated
            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                CacheKey<?> cacheKey = (CacheKey<?>) o;
                return Objects.equals(ip, cacheKey.ip) &&
                    Objects.equals(responseType, cacheKey.responseType);
";EQ_UNUSUAL
"        }
        return Collections.singletonMap(UserAgentProcessor.TYPE, new UserAgentProcessor.Factory(userAgentParsers));
    }

    static Map<String, UserAgentParser> createUserAgentParsers(Path userAgentConfigDirectory, UserAgentCache cache) throws IOException {
        Map<String, UserAgentParser> userAgentParsers = new HashMap<>();

        UserAgentParser defaultParser = new UserAgentParser(DEFAULT_PARSER_NAME,
                IngestUserAgentPlugin.class.getResourceAsStream(""/regexes.yml""), cache);
        userAgentParsers.put(DEFAULT_PARSER_NAME, defaultParser);

";NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE
"            }
        };
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        FieldDataValueSource that = (FieldDataValueSource) o;

";EQ_UNUSUAL
"    public String description() {
        return methodName + "": field("" + fieldData.getFieldName() + "")"";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;

        DateMethodValueSource that = (DateMethodValueSource) o;
";EQ_UNUSUAL
"    public String description() {
        return methodName + "": field("" + fieldData.getFieldName() + "")"";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;

        DateObjectValueSource that = (DateObjectValueSource) o;
";EQ_UNUSUAL
"    public int hashCode() {
        return 31 * getClass().hashCode() + fieldData.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        EmptyMemberValueSource other = (EmptyMemberValueSource) obj;
        if (!fieldData.equals(other.fieldData)) return false;
";EQ_UNUSUAL
"        this.fieldData = Objects.requireNonNull(fieldData);
        this.multiValueMode = Objects.requireNonNull(multiValueMode);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        FieldDataValueSource that = (FieldDataValueSource) o;

";EQ_UNUSUAL
"    public int hashCode() {
        return 31 * getClass().hashCode() + fieldData.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        GeoEmptyValueSource other = (GeoEmptyValueSource) obj;
        if (!fieldData.equals(other.fieldData)) return false;
";EQ_UNUSUAL
"    public int hashCode() {
        return 31 * getClass().hashCode() + fieldData.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        GeoLatitudeValueSource other = (GeoLatitudeValueSource) obj;
        if (!fieldData.equals(other.fieldData)) return false;
";EQ_UNUSUAL
"    public int hashCode() {
        return 31 * getClass().hashCode() + fieldData.hashCode();
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null) return false;
        if (getClass() != obj.getClass()) return false;
        GeoLongitudeValueSource other = (GeoLongitudeValueSource) obj;
        if (!fieldData.equals(other.fieldData)) return false;
";EQ_UNUSUAL
"        else
            return Explanation.noMatch(""ReplaceableConstDoubleValues"");
    }

    @Override
    public boolean equals(Object o) {
        return o == this;
    }

    @Override
    public int hashCode() {
";EQ_UNUSUAL
"
    /**
     * The list of responses, the order is the same as the one provided in the request.
     */
    public Item[] getResponses() {
        return this.items;
    }
    
    /**
     * How long the msearch_template took.
     */
";EI_EXPOSE_REP
"        this.client = client;
    }

    @Override
    protected void doExecute(Task task, SearchTemplateRequest request, ActionListener<SearchTemplateResponse> listener) {
        final SearchTemplateResponse response = new SearchTemplateResponse();
        try {
            SearchRequest searchRequest = convert(request, response, scriptService, xContentRegistry);
            if (searchRequest != null) {
                client.search(searchRequest, new ActionListener<SearchResponse>() {
                    @Override
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    @Override
    protected Collection<Class<? extends Plugin>> getPlugins() {
        return Collections.singleton(MustachePlugin.class);
    }

    @Before
    public void setup() throws IOException {
        createIndex(""test"");
        client().prepareIndex(""test"", ""type"", ""1"")
                .setSource(jsonBuilder().startObject().field(""text"", ""value1"").endObject())
                .get();
";NM_VERY_CONFUSING
" * parse an annotation against any whitelist object while loading.
 */
public interface WhitelistAnnotationParser {

    Map<String, WhitelistAnnotationParser> BASE_ANNOTATION_PARSERS = Collections.unmodifiableMap(
            Stream.of(
                    new AbstractMap.SimpleEntry<>(NoImportAnnotation.NAME, NoImportAnnotationParser.INSTANCE),
                    new AbstractMap.SimpleEntry<>(DeprecatedAnnotation.NAME, DeprecatedAnnotationParser.INSTANCE)
            ).collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue))
    );

";IC_SUPERCLASS_USES_SUBCLASS_DURING_INITIALIZATION
"     *   def value2
     * }
     * }
     */
    public static Whitelist loadFromResourceFiles(Class<?> resource, Map<String, WhitelistAnnotationParser> parsers, String... filepaths) {
        List<WhitelistClass> whitelistClasses = new ArrayList<>();
        List<WhitelistMethod> whitelistStatics = new ArrayList<>();
        List<WhitelistClassBinding> whitelistClassBindings = new ArrayList<>();

        // Execute a single pass through the whitelist text files.  This will gather all the
        // constructors, methods, augmented methods, and fields for each whitelisted class.
";REC_CATCH_EXCEPTION
"            stream.println(fieldInfo.getName());
        }
    }

    private static String getType(Map<String, String> javaNamesToDisplayNames, String javaType) {
        int arrayDimensions = 0;

        while (javaType.charAt(arrayDimensions) == '[') {
            ++arrayDimensions;
        }

";SBSC_USE_STRINGBUFFER_CONCATENATION
"            public void setXContentType(XContentType xContentType) {
                this.xContentType = xContentType;
            }

            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;
                ContextSetup that = (ContextSetup) o;
                return Objects.equals(index, that.index) &&
                    Objects.equals(document, that.document) &&
";EQ_UNUSUAL
"    /**
     * Return a new {@link Loader} for a script using the
     * {@link Compiler}'s specified {@link PainlessLookup}.
     */
    public Loader createLoader(ClassLoader parent) {
        return new Loader(parent);
    }

    /**
     * The class/interface the script will implement.
     */
";DP_CREATE_CLASSLOADER_INSIDE_DO_PRIVILEGED
"        }
        static Iterator<Object> iterator(final Object[] array) {
            return new Iterator<Object>() {
                int index = 0;
                @Override public boolean hasNext() { return index < array.length; }
                @Override public Object next() { return array[index++]; }
            };
        }

        static MethodHandle newIterator(Class<?> arrayType) {
            if (!arrayType.isArray()) {
";IT_NO_SUCH_ELEMENT
"    private static boolean plus(boolean v) {
        throw new ClassCastException(""Cannot apply [+] operation to type [boolean]"");
    }

    private static Object plus(final Object unary) {
        if (unary instanceof Double) {
            return +(double)unary;
        } else if (unary instanceof Long) {
            return +(long)unary;
        } else if (unary instanceof Integer) {
            return +(int)unary;
";BX_UNBOXING_IMMEDIATELY_REBOXED
"    }

    public void addImportedPainlessMethod(ClassLoader classLoader, String targetJavaClassName,
            String methodName, String returnCanonicalTypeName, List<String> canonicalTypeNameParameters) {

        Objects.requireNonNull(classLoader);
        Objects.requireNonNull(targetJavaClassName);
        Objects.requireNonNull(methodName);
        Objects.requireNonNull(returnCanonicalTypeName);
        Objects.requireNonNull(canonicalTypeNameParameters);

";RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE
"        }
    }

    @Override
    void analyze(Locals locals) {
        localMethod = locals.getMethod(name, arguments.size());

        if (localMethod == null) {
            importedMethod = locals.getPainlessLookup().lookupImportedPainlessMethod(name, arguments.size());

            if (importedMethod == null) {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
        actual = boolean.class;
    }

    private void analyzeNE(Locals variables) {
        left.analyze(variables);
        right.analyze(variables);

        promotedType = AnalyzerCaster.promoteEquality(left.actual, right.actual);

        if (promotedType == null) {
";EC_NULL_ARG
"    public String getPointer() {
        return defPointer;
    }

    @Override
    public org.objectweb.asm.Type[] getCaptures() {
        org.objectweb.asm.Type[] types = new org.objectweb.asm.Type[captures.size()];
        for (int i = 0; i < types.length; i++) {
            types[i] = MethodWriter.getType(captures.get(i).clazz);
        }
        return types;
";IL_INFINITE_RECURSIVE_LOOP
"            actual = promote;
        }
    }

    void analyzerAdd(Locals variables) {
        child.analyze(variables);

        promote = AnalyzerCaster.promoteNumeric(child.actual, true);

        if (promote == null) {
            throw createError(new ClassCastException(""Cannot apply positive [+] to type "" +
";BX_UNBOXING_IMMEDIATELY_REBOXED
"    public static String charToString(final char value) {
        return String.valueOf(value);
    }

    public static char StringTochar(final String value) {
        if (value == null) {
            throw new ClassCastException(""cannot cast "" +
                    ""null "" + String.class.getCanonicalName() +  "" to "" + char.class.getCanonicalName());
        }

        if (value.length() != 1) {
";NM_METHOD_NAMING_CONVENTION
"        public RankFeatureFieldType clone() {
            return new RankFeatureFieldType(this);
        }

        @Override
        public boolean equals(Object o) {
            if (super.equals(o) == false) {
                return false;
            }
            RankFeatureFieldType other = (RankFeatureFieldType) o;
            return Objects.equals(positiveScoreImpact, other.positiveScoreImpact);
";EQ_UNUSUAL
"        public AtomicNumericFieldData loadDirect(LeafReaderContext context) throws Exception {
            return new ScaledFloatLeafFieldData(scaledFieldData.loadDirect(context), scalingFactor);
        }

        @Override
        public SortField sortField(@Nullable Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {
            final XFieldComparatorSource source = new DoubleValuesComparatorSource(this, missingValue, sortMode, nested);
            return new SortField(getFieldName(), source, reverse);
        }

        @Override
";IL_INFINITE_RECURSIVE_LOOP
"                conflicts.add(""mapper ["" + name() + ""] has different [index_prefixes] settings"");
            }
        }

        @Override
        public boolean equals(Object otherObject) {
            if (this == otherObject) {
                return true;
            }
            if (otherObject == null || getClass() != otherObject.getClass()) {
                return false;
";EQ_UNUSUAL
"            private Sigmoid(StreamInput in) throws IOException {
                this(in.readFloat(), in.readFloat());
            }

            @Override
            public boolean equals(Object obj) {
                if (obj == null || obj.getClass() != getClass()) {
                    return false;
                }
                Sigmoid that = (Sigmoid) obj;
                return pivot == that.pivot
";EQ_UNUSUAL
"public class RankFeatureFieldMapperTests extends ESSingleNodeTestCase {

    IndexService indexService;
    DocumentMapperParser parser;

    @Before
    public void setup() {
        indexService = createIndex(""test"");
        parser = indexService.mapperService().documentMapperParser();
    }

";NM_VERY_CONFUSING
"public class RankFeatureMetaFieldMapperTests extends ESSingleNodeTestCase {

    IndexService indexService;
    DocumentMapperParser parser;

    @Before
    public void setup() {
        indexService = createIndex(""test"");
        parser = indexService.mapperService().documentMapperParser();
    }

";NM_VERY_CONFUSING
"public class RankFeaturesFieldMapperTests extends ESSingleNodeTestCase {

    IndexService indexService;
    DocumentMapperParser parser;

    @Before
    public void setup() {
        indexService = createIndex(""test"");
        parser = indexService.mapperService().documentMapperParser();
    }

";NM_VERY_CONFUSING
"public class ScaledFloatFieldMapperTests extends ESSingleNodeTestCase {

    IndexService indexService;
    DocumentMapperParser parser;

    @Before
    public void setup() {
        indexService = createIndex(""test"");
        parser = indexService.mapperService().documentMapperParser();
    }

";NM_VERY_CONFUSING
"    public int hashCode() {
        return Objects.hash(super.hashCode(), childType);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        if (super.equals(obj) == false) return false;
        ChildrenAggregationBuilder other = (ChildrenAggregationBuilder) obj;
        return Objects.equals(childType, other.childType);
";EQ_UNUSUAL
"    public int hashCode() {
        return Objects.hash(super.hashCode(), childType);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        if (super.equals(obj) == false) return false;
        ParentAggregationBuilder other = (ParentAggregationBuilder) obj;
        return Objects.equals(childType, other.childType);
";EQ_UNUSUAL
"     * Returns the {@link ParentJoinFieldMapper} associated with the <code>service</code> or null
     * if there is no parent-join field in this mapping.
     */
    public static ParentJoinFieldMapper getMapper(MapperService service) {
        MetaJoinFieldMapper.MetaJoinFieldType fieldType =
            (MetaJoinFieldMapper.MetaJoinFieldType) service.fullName(MetaJoinFieldMapper.NAME);
        return fieldType == null ? null : fieldType.getMapper();
    }

    private static String getParentIdFieldName(String joinFieldName, String parentName) {
        return joinFieldName + ""#"" + parentName;
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"                    reader.getClass() + "" must be a DirectoryReader"");
            }
        }

        @Override
        public boolean equals(Object o) {
            if (sameClassAs(o) == false) return false;

            LateParsingQuery that = (LateParsingQuery) o;

            if (minChildren != that.minChildren) return false;
";EQ_UNUSUAL
"        this.fetchChildInnerHits = fetchChildInnerHits;
    }

    @Override
    protected void doBuild(SearchContext context, InnerHitsContext innerHitsContext) throws IOException {
        QueryShardContext queryShardContext = context.getQueryShardContext();
        ParentJoinFieldMapper joinFieldMapper = ParentJoinFieldMapper.getMapper(context.mapperService());
        if (joinFieldMapper != null) {
            String name = innerHitBuilder.getName() != null ? innerHitBuilder.getName() : typeName;
            JoinFieldInnerHitSubContext joinFieldInnerHits = new JoinFieldInnerHitSubContext(name, context, typeName,
                fetchChildInnerHits, joinFieldMapper);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    // Comparing identity here to avoid being cached
    // Note that in theory if the same instance gets used multiple times it could still get cached,
    // however since we create a new query instance each time we this query this shouldn't happen and thus
    // this risk neglectable.
    @Override
    public boolean equals(Object o) {
        return this == o;
    }

    // Computing hashcode based on identity to avoid caching.
    @Override
";EQ_UNUSUAL
"            this.queryShardContext = queryShardContext;
        }

        @Override
        public PercolatorFieldMapper build(BuilderContext context) {
            context.path().add(name());
            FieldType fieldType = (FieldType) this.fieldType;
            KeywordFieldMapper extractedTermsField = createExtractQueryFieldBuilder(EXTRACTED_TERMS_FIELD_NAME, context);
            fieldType.queryTermsField = extractedTermsField.fieldType();
            KeywordFieldMapper extractionResultField = createExtractQueryFieldBuilder(EXTRACTION_RESULT_FIELD_NAME, context);
            fieldType.extractionResultField = extractionResultField.fieldType();
";DLS_DEAD_LOCAL_STORE
"            // using BytesRef here just to make use of its compareTo method.
            this.interval = new BytesRef(interval);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Range range = (Range) o;
            return Objects.equals(fieldName, range.fieldName) &&
                Arrays.equals(lowerPoint, range.lowerPoint) &&
";EQ_UNUSUAL
"        public String toString(String field) {
            return ""custom{"" + field + ""}"";
        }

        @Override
        public boolean equals(Object obj) {
            return sameClassAs(obj);
        }

        @Override
        public int hashCode() {
";EQ_UNUSUAL
"    /**
     * @return the indices for this request
     */
    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public IndicesOptions indicesOptions() {
        return indicesOptions;
";EI_EXPOSE_REP
"        return Strings.toString(this);
    }

    @Override
    public void writeTo(StreamOutput out) throws IOException {
        out.writeDouble(metricScore);
        out.writeVInt(details.size());
        for (String queryId : details.keySet()) {
            out.writeString(queryId);
            details.get(queryId).writeTo(out);
        }
";WMI_WRONG_MAP_ITERATOR
"        this.summaryFields = new ArrayList<>();
    }

    static void validateEvaluatedQuery(SearchSourceBuilder evaluationRequest) {
        // ensure that testRequest, if set, does not contain aggregation, suggest or highlighting section
        if (evaluationRequest != null) {
            if (evaluationRequest.suggest() != null) {
                throw new IllegalArgumentException(""Query in rated requests should not contain a suggest section."");
            }
            if (evaluationRequest.aggregations() != null) {
                throw new IllegalArgumentException(""Query in rated requests should not contain aggregations."");
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            }
        };
    }

    private static Integer parseSlices(RestRequest request) {
        String slicesString = request.param(""slices"");
        if (slicesString == null) {
            return null;
        }

        if (slicesString.equals(AbstractBulkByScrollRequest.AUTO_SLICES_VALUE)) {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            Client client,
            DiscoveryNode node,
            Runnable workerAction,
            int slices) {

        if (slices > 1) {
            task.setWorkerCount(slices);
            sendSubRequests(client, action, node.getId(), task, request, listener);
        } else {
            SliceBuilder sliceBuilder = request.getSearchRequest().source().slice();
            Integer sliceId = sliceBuilder == null
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        this.clusterService = clusterService;
    }

    @Override
    public void doExecute(Task task, DeleteByQueryRequest request, ActionListener<BulkByScrollResponse> listener) {
        BulkByScrollTask bulkByScrollTask = (BulkByScrollTask) task;
        BulkByScrollParallelizationHelper.startSlicedAction(request, bulkByScrollTask, DeleteByQueryAction.INSTANCE, listener, client,
            clusterService.localNode(),
            () -> {
                ClusterState state = clusterService.state();
                ParentTaskAssigningClient assigningClient = new ParentTaskAssigningClient(client, clusterService.localNode(),
";BC_UNCONFIRMED_CAST
"    public String toString(String field) {
        return ""BinaryDocValuesRangeQuery(fieldName="" + field + "",from="" + originalFrom + "",to="" + originalTo + "")"";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        BinaryDocValuesRangeQuery that = (BinaryDocValuesRangeQuery) o;
        return Objects.equals(fieldName, that.fieldName) &&
                queryType == that.queryType &&
";EQ_UNUSUAL
"        return equalTerms;

    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (sameClassAs(o) == false) return false;

        BlendedTermQuery that = (BlendedTermQuery) o;
        return Arrays.equals(equalsTerms(), that.equalsTerms());
";EQ_UNUSUAL
"    public int hashCode() {
        return Objects.hash(classHash(), minDoc, readerId);
    }

    @Override
    public boolean equals(Object obj) {
        if (sameClassAs(obj) == false) {
            return false;
        }
        MinDocQuery that = (MinDocQuery) obj;
        return minDoc == that.minDoc && Objects.equals(readerId, that.readerId);
";EQ_UNUSUAL
"    public String toString(String field) {
        return ""SearchAfterSortedDocQuery(sort="" + sort  + "", afterDoc="" + after.toString() + "")"";
    }

    @Override
    public boolean equals(Object other) {
        return sameClassAs(other) &&
            equalsTo(getClass().cast(other));
    }

    private boolean equalsTo(SearchAfterSortedDocQuery other) {
";EQ_UNUSUAL
"    public String toString(String field) {
        return ""SpanMatchNoDocsQuery(\"""" + reason + ""\"")"";
    }

    @Override
    public boolean equals(Object o) {
        return sameClassAs(o);
    }

    @Override
    public int hashCode() {
";EQ_UNUSUAL
"     * Construct a request to add voting config exclusions for master-eligible nodes matching the given descriptions, and wait for these
     * nodes to be removed from the voting configuration.
     * @param nodeDescriptions Descriptions of the nodes whose exclusions to add - see {@link DiscoveryNodes#resolveNodes(String...)}.
     * @param timeout How long to wait for the added exclusions to take effect and be removed from the voting configuration.
     */
    public AddVotingConfigExclusionsRequest(String[] nodeDescriptions, TimeValue timeout) {
        if (timeout.compareTo(TimeValue.ZERO) < 0) {
            throw new IllegalArgumentException(""timeout ["" + timeout + ""] must be non-negative"");
        }
        this.nodeDescriptions = nodeDescriptions;
        this.timeout = timeout;
";EI_EXPOSE_REP2
"                                                       ActionListener<ClearVotingConfigExclusionsResponse> listener) {
        clusterService.submitStateUpdateTask(""clear-voting-config-exclusions"", new ClusterStateUpdateTask(Priority.URGENT) {
            @Override
            public ClusterState execute(ClusterState currentState) {
                final CoordinationMetaData newCoordinationMetaData =
                        CoordinationMetaData.builder(currentState.coordinationMetaData()).clearVotingConfigExclusions().build();
                final MetaData newMetaData = MetaData.builder(currentState.metaData()).
                        coordinationMetaData(newCoordinationMetaData).build();
                return ClusterState.builder(currentState).metaData(newMetaData).build();
            }

";DLS_DEAD_LOCAL_STORE
"        }
    }

    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public ClusterHealthRequest indices(String... indices) {
        this.indices = indices;
";EI_EXPOSE_REP
"        taskOperationFailures, List<FailedNodeException> failedNodeExceptions) {
        return new CancelTasksResponse(tasks, taskOperationFailures, failedNodeExceptions);
    }

    protected void processTasks(CancelTasksRequest request, Consumer<CancellableTask> operation) {
        if (request.getTaskId().isSet()) {
            // we are only checking one task, we can optimize it
            CancellableTask task = taskManager.getCancellableTask(request.getTaskId().getId());
            if (task != null) {
                if (request.match(task)) {
                    operation.accept(task);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"     * Executed on the coordinating node to forward execution of the remaining work to the node that matches that requested
     * {@link TaskId#getNodeId()}. If the node isn't in the cluster then this will just proceed to
     * {@link #getFinishedTaskFromIndex(Task, GetTaskRequest, ActionListener)} on this node.
     */
    private void runOnNodeWithTaskIfPossible(Task thisTask, GetTaskRequest request, ActionListener<GetTaskResponse> listener) {
        TransportRequestOptions.Builder builder = TransportRequestOptions.builder();
        if (request.getTimeout() != null) {
            builder.withTimeout(request.getTimeout());
        }
        DiscoveryNode node = clusterService.state().nodes().get(request.getTaskId().getNodeId());
        if (node == null) {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return childTasks;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject();
        task.toXContent(builder, params);
        if (childTasks.isEmpty() == false) {
            builder.startArray(""children"");
            for (TaskGroup taskGroup : childTasks) {
                taskGroup.toXContent(builder, params);
";NP_UNWRITTEN_FIELD
"     *
     * @param repositories list of repositories
     * @return this request
     */
    public GetRepositoriesRequest repositories(String[] repositories) {
        this.repositories = repositories;
        return this;
    }

    @Override
    public void readFrom(StreamInput in) throws IOException {
";EI_EXPOSE_REP2
"    }

    @Override
    protected void masterOperation(Task task, final GetRepositoriesRequest request, ClusterState state,
                                   final ActionListener<GetRepositoriesResponse> listener) {
        MetaData metaData = state.metaData();
        RepositoriesMetaData repositories = metaData.custom(RepositoriesMetaData.TYPE);
        if (request.repositories().length == 0 || (request.repositories().length == 1 && ""_all"".equals(request.repositories()[0]))) {
            if (repositories != null) {
                listener.onResponse(new GetRepositoriesResponse(repositories));
            } else {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return persistentUpdates.build();
    }

    synchronized ClusterState updateSettings(
            final ClusterState currentState, final Settings transientToApply, final Settings persistentToApply, final Logger logger) {
        boolean changed = false;

        /*
         * Our cluster state could have unknown or invalid settings that are known and valid in a previous version of Elasticsearch. We can
         * end up in this situation during a rolling upgrade where the previous version will infect the current version of Elasticsearch
         * with settings that the current version either no longer knows about or now considers to have invalid values. When the current
";DLS_DEAD_LOCAL_STORE
"public class ClusterSearchShardsGroup implements Writeable, ToXContentObject {

    private final ShardId shardId;
    private final ShardRouting[] shards;

    public ClusterSearchShardsGroup(ShardId shardId, ShardRouting[] shards) {
        this.shardId = shardId;
        this.shards = shards;
    }

    ClusterSearchShardsGroup(StreamInput in) throws IOException {
";EI_EXPOSE_REP2
"    /**
     * The indices
     */
    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public IndicesOptions indicesOptions() {
        return indicesOptions;
";EI_EXPOSE_REP
"            out.writeString(entry.getKey());
            entry.getValue().writeTo(out);
        }
    }

    public ClusterSearchShardsResponse(ClusterSearchShardsGroup[] groups, DiscoveryNode[] nodes,
                                       Map<String, AliasFilter> indicesAndFilters) {
        this.groups = groups;
        this.nodes = nodes;
        this.indicesAndFilters = indicesAndFilters;
    }
";EI_EXPOSE_REP2
"     *
     * @return list of indices
     */
    @Override
    public String[] indices() {
        return indices;
    }

    /**
     * Specifies the indices options. Like what type of requested indices to ignore. For example indices that don't exist.
     *
";EI_EXPOSE_REP
"     * Sets the list of snapshots to be returned
     *
     * @return this request
     */
    public GetSnapshotsRequest snapshots(String[] snapshots) {
        this.snapshots = snapshots;
        return this;
    }

    /**
     * Set to true to ignore unavailable snapshots
";EI_EXPOSE_REP2
"
    /**
     * Returns list of indices that should be restored from snapshot
     */
    public String[] indices() {
        return indices;
    }

    /**
     * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.
     * For example indices that don't exist.
";EI_EXPOSE_REP
"    @Override
    protected void masterOperation(Task task, final RestoreSnapshotRequest request, final ClusterState state,
                                   final ActionListener<RestoreSnapshotResponse> listener) {
        restoreService.restoreSnapshot(request, ActionListener.delegateFailure(listener,
            (delegatedListener, restoreCompletionResponse) -> {
                if (restoreCompletionResponse.getRestoreInfo() == null && request.waitForCompletion()) {
                    RestoreClusterStateListener.createAndRegisterListener(clusterService, restoreCompletionResponse, delegatedListener);
                } else {
                    delegatedListener.onResponse(new RestoreSnapshotResponse(restoreCompletionResponse.getRestoreInfo()));
                }
            }));
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"     * Sets the list of snapshots to be returned
     *
     * @return this request
     */
    public SnapshotsStatusRequest snapshots(String[] snapshots) {
        this.snapshots = snapshots;
        return this;
    }

    /**
     * Set to <code>true</code> to ignore unavailable snapshots, instead of throwing an exception.
";EI_EXPOSE_REP2
"        public Request(String[] nodesIds) {
            super(nodesIds);
        }

        public Request snapshots(Snapshot[] snapshots) {
            this.snapshots = snapshots;
            return this;
        }

        @Override
        public void readFrom(StreamInput in) throws IOException {
";EI_EXPOSE_REP2
"        return this;
    }

    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public ClusterStateRequest indices(String... indices) {
        this.indices = indices;
";EI_EXPOSE_REP
"    ClusterStatsNodeResponse() {
    }

    public ClusterStatsNodeResponse(DiscoveryNode node, @Nullable ClusterHealthStatus clusterStatus,
                                    NodeInfo nodeInfo, NodeStats nodeStats, ShardStats[] shardsStats) {
        super(node);
        this.nodeInfo = nodeInfo;
        this.nodeStats = nodeStats;
        this.shardsStats = shardsStats;
        this.clusterStatus = clusterStatus;
    }
";EI_EXPOSE_REP2
"        return this;
    }

    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public String[] aliases() {
        return aliases;
";EI_EXPOSE_REP
"            return type == Type.REMOVE;
        }

        @Override
        public String[] indices() {
            return indices;
        }

        @Override
        public IndicesOptions indicesOptions() {
            return INDICES_OPTIONS;
";EI_EXPOSE_REP
"        public Request(String index) {
            this.index(index);
        }

        public String[] text() {
            return this.text;
        }

        public Request text(String... text) {
            this.text = text;
            return this;
";EI_EXPOSE_REP
"        this.fields = fields == null ? Strings.EMPTY_ARRAY : fields;
        return this;
    }

    public String[] fields() {
        return this.fields;
    }

    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
";EI_EXPOSE_REP
"     * The indices to be closed
     * @return the indices to be closed
     */
    @Override
    public String[] indices() {
        return indices;
    }

    /**
     * Sets the indices to be closed
     * @param indices the indices to be closed
";EI_EXPOSE_REP
"    public static class ShardResult implements Writeable, ToXContentFragment {

        private final int id;
        private final Failure[] failures;

        public ShardResult(final int id, final Failure[] failures) {
            this.id = id;
            this.failures = failures;
        }

        ShardResult(final StreamInput in) throws IOException {
";EI_EXPOSE_REP2
"    /**
     * The index to delete.
     */
    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
";EI_EXPOSE_REP
"        public void readFrom(StreamInput in) throws IOException {
            total = in.readInt();
            successful = in.readInt();
            failed = in.readInt();
        }

        @Override
        public void writeTo(StreamOutput out) throws IOException {
            out.writeInt(total);
            out.writeInt(successful);
            out.writeInt(failed);
";HE_EQUALS_USE_HASHCODE
"
        Feature(byte id) {
            this.id = id;
        }

        public byte id() {
            return id;
        }

        public static Feature fromId(byte id) {
            if (id < 0 || id >= FEATURES.length) {
";EI_EXPOSE_REP
"        if (mappings != null) {
            this.mappings = mappings;
        }
        if (aliases != null) {
            this.aliases = aliases;
        }
        if (settings != null) {
            this.settings = settings;
        }
        if (defaultSettings != null) {
            this.defaultSettings = defaultSettings;
";EI_EXPOSE_REP
"    public ActionRequestValidationException validate() {
        return null;
    }

    public String[] types() {
        return types;
    }

    public String[] fields() {
        return fields;
    }
";EI_EXPOSE_REP
"     */
    public GetFieldMappingsRequest local(boolean local) {
        this.local = local;
        return this;
    }

    public boolean local() {
        return local;
    }

    @Override
";EI_EXPOSE_REP
"null
null
null
null
null
null
null
null
null
null
null
";EI_EXPOSE_REP
"        return state.routingTable().index(request.concreteIndex()).randomAllActiveShardsIt();
    }

    @Override
    protected GetFieldMappingsResponse shardOperation(final GetFieldMappingsIndexRequest request, ShardId shardId) {
        assert shardId != null;
        IndexService indexService = indicesService.indexServiceSafe(shardId.getIndex());
        Version indexCreatedVersion = indexService.mapperService().getIndexSettings().getIndexVersionCreated();
        Predicate<String> metadataFieldPredicate = (f) -> indicesService.isMetaDataField(indexCreatedVersion, f);
        Predicate<String> fieldPredicate = metadataFieldPredicate.or(indicesService.getFieldFilter().apply(shardId.getIndexName()));

";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
" * @see AcknowledgedResponse
 */
public class PutMappingRequest extends AcknowledgedRequest<PutMappingRequest> implements IndicesRequest.Replaceable, ToXContentObject {

    private static ObjectHashSet<String> RESERVED_FIELDS = ObjectHashSet.from(
            ""_uid"", ""_id"", ""_type"", ""_source"",  ""_all"", ""_analyzer"", ""_parent"", ""_routing"", ""_index"",
            ""_size"", ""_timestamp"", ""_ttl"", ""_field_names""
    );

    private String[] indices;

";EI_EXPOSE_REP
"    }

    @Override
    protected ClusterBlockException checkBlock(PutMappingRequest request, ClusterState state) {
        String[] indices;
        if (request.getConcreteIndex() == null) {
            indices = indexNameExpressionResolver.concreteIndexNames(state, request);
        } else {
            indices = new String[] {request.getConcreteIndex().getName()};
        }
        return state.blocks().indicesBlockedException(ClusterBlockLevel.METADATA_WRITE, indices);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"     * The indices to be opened
     * @return the indices to be opened
     */
    @Override
    public String[] indices() {
        return indices;
    }

    /**
     * Sets the indices to be opened
     * @param indices the indices to be opened
";EI_EXPOSE_REP
"        return shardRecoveryStates;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject();
        if (hasRecoveries()) {
            for (String index : shardRecoveryStates.keySet()) {
                List<RecoveryState> recoveryStates = shardRecoveryStates.get(index);
                if (recoveryStates == null || recoveryStates.size() == 0) {
                    continue;
";WMI_WRONG_MAP_ITERATOR
"                                ActionListener.wrap(aliasClusterStateUpdateResponse -> {
                                    if (aliasClusterStateUpdateResponse.isAcknowledged()) {
                                        clusterService.submitStateUpdateTask(""update_rollover_info"", new ClusterStateUpdateTask() {
                                            @Override
                                            public ClusterState execute(ClusterState currentState) {
                                                RolloverInfo rolloverInfo = new RolloverInfo(rolloverRequest.getAlias(), metConditions,
                                                    threadPool.absoluteTimeInMillis());
                                                return ClusterState.builder(currentState)
                                                    .metaData(MetaData.builder(currentState.metaData())
                                                        .put(IndexMetaData.builder(currentState.metaData().index(sourceIndexName))
                                                            .putRolloverInfo(rolloverInfo))).build();
";DLS_DEAD_LOCAL_STORE
"    public ShardSegments getAt(int i) {
        return shards[i];
    }

    public ShardSegments[] getShards() {
        return this.shards;
    }

    @Override
    public Iterator<ShardSegments> iterator() {
        return Arrays.stream(shards).iterator();
";EI_EXPOSE_REP
"    public IndicesOptions indicesOptions() {
        return indicesOptions;
    }

    public String[] names() {
        return names;
    }

    public GetSettingsRequest names(String... names) {
        this.names = names;
        return this;
";EI_EXPOSE_REP
"        return validationException;
    }

    @Override
    public String[] indices() {
        return indices;
    }

    public Settings settings() {
        return settings;
    }
";EI_EXPOSE_REP
"        return statuses;
    }

    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public IndicesOptions indicesOptions() {
        return indicesOptions;
";EI_EXPOSE_REP
"            return builder;
        }

        @Override
        public int compareTo(StoreStatus other) {
            if (storeException != null && other.storeException == null) {
                return 1;
            } else if (other.storeException != null && storeException == null) {
                return -1;
            }
            if (allocationId != null && other.allocationId == null) {
";EQ_COMPARETO_USE_OBJECT_EQUALS
"        this.sourceIndex = sourceIndex;
    }

    @Override
    public ActionRequestValidationException validate() {
        ActionRequestValidationException validationException = targetIndexRequest == null ? null : targetIndexRequest.validate();
        if (sourceIndex == null) {
            validationException = addValidationError(""source index is missing"", validationException);
        }
        if (targetIndexRequest == null) {
            validationException = addValidationError(""target index request is missing"", validationException);
";NP_NULL_ON_SOME_PATH
"    /**
     * Document types to return stats for. Mainly affects {@link Flag#Indexing} when
     * enabled, returning specific indexing stats for those types.
     */
    public String[] types() {
        return this.types;
    }

    /**
     * Sets specific search group stats to retrieve the stats for. Mainly affects search
     * when enabled.
";EI_EXPOSE_REP
"
    private ShardStats[] shards;

    private IndexShardStats() {}

    public IndexShardStats(ShardId shardId, ShardStats[] shards) {
        this.shardId = shardId;
        this.shards = shards;
    }

    public ShardId getShardId() {
";EI_EXPOSE_REP2
"
    private final String uuid;

    private final ShardStats shards[];

    public IndexStats(String index, String uuid, ShardStats[] shards) {
        this.index = index;
        this.uuid = uuid;
        this.shards = shards;
    }

";EI_EXPOSE_REP2
"        }
        return this.shardStatsMap;
    }

    public ShardStats[] getShards() {
        return this.shards;
    }

    public ShardStats getAt(int position) {
        return shards[position];
    }
";EI_EXPOSE_REP
"
    /**
     * The names of the index templates.
     */
    public String[] names() {
        return this.names;
    }

    @Override
    public void readFrom(StreamInput in) throws IOException {
        throw new UnsupportedOperationException(""usage of Streamable is to be replaced by Writeable"");
";EI_EXPOSE_REP
"    public ShardUpgradeStatus getAt(int i) {
        return shards[i];
    }

    public ShardUpgradeStatus[] getShards() {
        return this.shards;
    }

    @Override
    public Iterator<ShardUpgradeStatus> iterator() {
        return Arrays.stream(shards).iterator();
";EI_EXPOSE_REP
"        this.versions = versions;
    }

    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        int size = in.readVInt();
        versions = new HashMap<>();
        for (int i=0; i<size; i++) {
            String index = in.readString();
            Version upgradeVersion = Version.readVersion(in);
";DLS_DEAD_LOCAL_STORE
"    }


    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
        int size = in.readVInt();
        versions = new HashMap<>();
        for (int i=0; i<size; i++) {
            String index = in.readString();
            Version upgradeVersion = Version.readVersion(in);
";DLS_DEAD_LOCAL_STORE
"    public QueryBuilder query() {
        return query;
    }

    public String[] types() {
        return this.types;
    }

    public boolean explain() {
        return this.explain;
    }
";EI_EXPOSE_REP
"     * @deprecated Types are in the process of being removed. Instead of using a type, prefer to
     * filter on a field on the document.
     */
    @Deprecated
    public String[] types() {
        return this.types;
    }

    /**
     * The types of documents the query will run against. Defaults to all types.
     *
";EI_EXPOSE_REP
"            }
        }
    }

    boolean awaitClose(long timeout, TimeUnit unit) throws InterruptedException {
        if (semaphore.tryAcquire(this.concurrentRequests, timeout, unit)) {
            semaphore.release(this.concurrentRequests);
            return true;
        }
        return false;
    }
";NP_UNWRITTEN_FIELD
"
    public BulkResponse(BulkItemResponse[] responses, long tookInMillis) {
        this(responses, tookInMillis, NO_INGEST_TOOK);
    }

    public BulkResponse(BulkItemResponse[] responses, long tookInMillis, long ingestTookInMillis) {
        this.responses = responses;
        this.tookInMillis = tookInMillis;
        this.ingestTookInMillis = ingestTookInMillis;
    }

";EI_EXPOSE_REP2
"            }
        }
    }

    public BulkShardRequest(ShardId shardId, RefreshPolicy refreshPolicy, BulkItemRequest[] items) {
        super(shardId);
        this.items = items;
        setRefreshPolicy(refreshPolicy);
    }

    public BulkItemRequest[] items() {
";EI_EXPOSE_REP2
"
    BulkShardResponse() {
    }

    // NOTE: public for testing only
    public BulkShardResponse(ShardId shardId, BulkItemResponse[] responses) {
        this.shardId = shardId;
        this.responses = responses;
    }

    public ShardId getShardId() {
";EI_EXPOSE_REP2
"    public String[] storedFields() {
        return storedFields;
    }

    public ExplainRequest storedFields(String[] fields) {
        this.storedFields = fields;
        return this;
    }

    public AliasFilter filteringAlias() {
        return filteringAlias;
";EI_EXPOSE_REP2
"        }
        ExplainResponse other = (ExplainResponse) obj;
        return index.equals(other.index)
            && type.equals(other.type)
            && id.equals(other.id)
            && Objects.equals(explanation, other.explanation)
            && getResult.isExists() == other.getResult.isExists()
            && Objects.equals(getResult.sourceAsMap(), other.getResult.sourceAsMap())
            && Objects.equals(getResult.getFields(), other.getResult.getFields());
    }

";EQ_UNUSUAL
"     * @param nonSearchableIndices The list of indices where this field is not searchable,
     *                             or null if the field is searchable in all indices.
     * @param nonAggregatableIndices The list of indices where this field is not aggregatable,
     *                               or null if the field is aggregatable in all indices.
     */
    public FieldCapabilities(String name, String type,
                      boolean isSearchable, boolean isAggregatable,
                      String[] indices,
                      String[] nonSearchableIndices,
                      String[] nonAggregatableIndices) {
        this.name = name;
";EI_EXPOSE_REP2
"        this.index(index);
        this.originalIndices = originalIndices;
    }

    public String[] fields() {
        return fields;
    }

    @Override
    public String[] indices() {
        return originalIndices.indices();
";EI_EXPOSE_REP
"        return this;
    }

    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public IndicesOptions indicesOptions() {
        return indicesOptions;
";EI_EXPOSE_REP
"
    /**
     * Get the concrete list of indices that were requested.
     */
    public String[] getIndices() {
        return indices;
    }


    /**
     * Get the field capabilities map.
";EI_EXPOSE_REP
"        return state.routingTable().index(request.concreteIndex()).randomAllActiveShardsIt();
    }

    @Override
    protected FieldCapabilitiesIndexResponse shardOperation(final FieldCapabilitiesIndexRequest request, ShardId shardId) {
        MapperService mapperService = indicesService.indexServiceSafe(shardId.getIndex()).mapperService();
        Set<String> fieldNames = new HashSet<>();
        for (String field : request.fields()) {
            fieldNames.addAll(mapperService.simpleMatchToFullName(field));
        }
        Predicate<String> fieldPredicate = indicesService.getFieldFilter().apply(shardId.getIndexName());
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    /**
     * Explicitly specify the stored fields that will be returned. By default, the {@code _source}
     * field will be returned.
     */
    public String[] storedFields() {
        return this.storedFields;
    }

    /**
     * Should a refresh be executed before this get operation causing the operation to
     * return the latest value. Note, heavy get should not set this to {@code true}. Defaults
";EI_EXPOSE_REP
"            this.storedFields = fields;
            return this;
        }

        public String[] storedFields() {
            return this.storedFields;
        }

        public long version() {
            return version;
        }
";EI_EXPOSE_REP
"    private MultiGetItemResponse[] responses;

    MultiGetResponse() {
    }

    public MultiGetResponse(MultiGetItemResponse[] responses) {
        this.responses = responses;
    }

    public MultiGetItemResponse[] getResponses() {
        return this.responses;
";EI_EXPOSE_REP2
"        super.writeTo(out);
        out.writeStringArray(ids);
    }

    public String[] getIds() {
        return ids;
    }

    @Override
    public ActionRequestValidationException validate() {
        return null;
";EI_EXPOSE_REP
"        this.executionService = new SimulateExecutionService(threadPool);
    }

    @Override
    protected void doExecute(Task task, SimulatePipelineRequest request, ActionListener<SimulatePipelineResponse> listener) {
        final Map<String, Object> source = XContentHelper.convertToMap(request.getSource(), false, request.getXContentType()).v2();

        final SimulatePipelineRequest.Parsed simulateRequest;
        try {
            if (request.getId() != null) {
                simulateRequest = SimulatePipelineRequest.parseWithPipelineId(request.getId(), source, request.isVerbose(), ingestService);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    public OriginalIndices(IndicesRequest indicesRequest) {
        this(indicesRequest.indices(), indicesRequest.indicesOptions());
    }

    public OriginalIndices(String[] indices, IndicesOptions indicesOptions) {
        this.indices = indices;
        this.indicesOptions = indicesOptions;
    }

    @Override
";EI_EXPOSE_REP2
"        operations = in.readArray(Translog.Operation::readOperation, Translog.Operation[]::new);
    }

    public ResyncReplicationRequest(final ShardId shardId, final long trimAboveSeqNo, final long maxSeenAutoIdTimestampOnPrimary,
                                    final Translog.Operation[]operations) {
        super(shardId);
        this.trimAboveSeqNo = trimAboveSeqNo;
        this.maxSeenAutoIdTimestampOnPrimary = maxSeenAutoIdTimestampOnPrimary;
        this.operations = operations;
    }

";EI_EXPOSE_REP2
"    private final Map<String, PendingExecutions> pendingExecutionsPerNode = new ConcurrentHashMap<>();
    private final boolean throttleConcurrentRequests;

    InitialSearchPhase(String name, SearchRequest request, GroupShardsIterator<SearchShardIterator> shardsIts, Logger logger,
                       int maxConcurrentRequestsPerNode, Executor executor) {
        super(name);
        this.request = request;
        final List<SearchShardIterator> toSkipIterators = new ArrayList<>();
        final List<SearchShardIterator> iterators = new ArrayList<>();
        for (final SearchShardIterator iterator : shardsIts) {
            if (iterator.skip()) {
";UC_USELESS_OBJECT
"            items[i] = new Item(in);
        }
        tookInMillis = in.readVLong();
    }

    public MultiSearchResponse(Item[] items, long tookInMillis) {
        this.items = items;
        this.tookInMillis = tookInMillis;
    }

    @Override
";EI_EXPOSE_REP2
"    public SearchPhaseExecutionException(String phaseName, String msg, ShardSearchFailure[] shardFailures) {
        this(phaseName, msg, null, shardFailures);
    }

    public SearchPhaseExecutionException(String phaseName, String msg, Throwable cause, ShardSearchFailure[] shardFailures) {
        super(msg, deduplicateCause(cause, shardFailures));
        this.phaseName = phaseName;
        this.shardFailures = shardFailures;
    }

    public SearchPhaseExecutionException(StreamInput in) throws IOException {
";EI_EXPOSE_REP2
"     *
     * @param in The stream the request is read from
     * @throws IOException if there is an issue reading the stream
     */
    public SearchRequest(StreamInput in) throws IOException {
        super(in);
        searchType = SearchType.fromId(in.readByte());
        indices = in.readStringArray();
        routing = in.readOptionalString();
        preference = in.readOptionalString();
        scroll = in.readOptionalWriteable(Scroll::new);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        scrollId = in.readOptionalString();
        tookInMillis = in.readVLong();
        skippedShards = in.readVInt();
    }

    public SearchResponse(SearchResponseSections internalResponse, String scrollId, int totalShards, int successfulShards,
                          int skippedShards, long tookInMillis, ShardSearchFailure[] shardFailures, Clusters clusters) {
        this.internalResponse = internalResponse;
        this.scrollId = scrollId;
        this.clusters = clusters;
        this.totalShards = totalShards;
";EI_EXPOSE_REP2
"     * This is not perfect and makes a big assumption, that all nodes have the same thread pool size / have the number of processors and
     * that shard of the indices the search requests go to are more or less evenly distributed across all nodes in the cluster. But I think
     * it is a good enough default for most cases, if not then the default should be overwritten in the request itself.
     */
    static int defaultMaxConcurrentSearches(int availableProcessors, ClusterState state) {
        int numDateNodes = state.getNodes().getDataNodes().size();
        // availableProcessors will never be larger than 32, so max defaultMaxConcurrentSearches will never be larger than 49,
        // but we don't know about about other search requests that are being executed so lets cap at 10 per node
        int defaultSearchThreadPoolSize = Math.min(ThreadPool.searchThreadPoolSize(availableProcessors), 10);
        return Math.max(1, numDateNodes * defaultSearchThreadPoolSize);
    }
";DLS_DEAD_LOCAL_STORE
"                               OriginalIndices localIndices, String[] concreteIndices, Map<String, Set<String>> routingMap,
                               Map<String, AliasFilter> aliasFilter, Map<String, Float> concreteIndexBoosts,
                               List<SearchShardIterator> remoteShardIterators, BiFunction<String, String, DiscoveryNode> remoteConnections,
                               ClusterState clusterState, ActionListener<SearchResponse> listener, SearchResponse.Clusters clusters) {

        Map<String, Long> nodeSearchCounts = searchTransportService.getPendingSearchRequests();
        GroupShardsIterator<ShardIterator> localShardsIterator = clusterService.operationRouting().searchShards(clusterState,
                concreteIndices, routingMap, searchRequest.preference(), searchService.getResponseCollectorService(), nodeSearchCounts);
        GroupShardsIterator<SearchShardIterator> shardIterators = mergeShardsIterators(localShardsIterator, localIndices,
            searchRequest.getLocalClusterAlias(), remoteShardIterators);

";UPM_UNCALLED_PRIVATE_METHOD
"
    /**
     * Returns the action filters that have been injected
     */
    public ActionFilter[] filters() {
        return filters;
    }
}
null
null
null
";EI_EXPOSE_REP
"        this.indicesOptions = indicesOptions;
    }

    @Override
    public String[] indices() {
        return indices;
    }

    @SuppressWarnings(""unchecked"")
    @Override
    public final Request indices(String... indices) {
";EI_EXPOSE_REP
"
    /**
     * The list of shard failures exception.
     */
    public DefaultShardOperationFailedException[] getShardFailures() {
        return shardFailures;
    }

    @Override
    public void readFrom(StreamInput in) throws IOException {
        super.readFrom(in);
";EI_EXPOSE_REP
"            Request request,
            AtomicReferenceArray responses,
            List<NoShardAvailableActionException> unavailableShardExceptions,
            Map<String, List<ShardRouting>> nodes,
            ClusterState clusterState) {
        int totalShards = 0;
        int successfulShards = 0;
        List<ShardOperationResult> broadcastByNodeResponses = new ArrayList<>();
        List<DefaultShardOperationFailedException> exceptions = new ArrayList<>();
        for (int i = 0; i < responses.length(); i++) {
            if (responses.get(i) instanceof FailedNodeException) {
";UPM_UNCALLED_PRIVATE_METHOD
"                }
            }
        }

        protected void performOperation(final ShardIterator shardIt, final ShardRouting shard, final int shardIndex) {
            if (shard == null) {
                // no more active shards... (we should not really get here, just safety)
                onOperation(null, shardIt, shardIndex, new NoShardAvailableActionException(shardIt.shardId()));
            } else {
                try {
                    final ShardRequest shardRequest = newShardRequest(shardIt.size(), shard, request);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    public AcknowledgedResponse(boolean acknowledged) {
        this.acknowledged = acknowledged;
    }

    /**
     * Returns whether the response is acknowledged or not
     * @return true if the response is acknowledged, false otherwise
     */
    public final boolean isAcknowledged() {
        return acknowledged;
    }
";EQ_DOESNT_OVERRIDE_EQUALS
"    public String[] indices() {
        return indices;
    }

    public String[] types() {
        return types;
    }

    @Override
    public IndicesOptions indicesOptions() {
        return indicesOptions;
";EI_EXPOSE_REP
"    public DiscoveryNode[] concreteNodes() {
        return concreteNodes;
    }

    public void setConcreteNodes(DiscoveryNode[] concreteNodes) {
        this.concreteNodes = concreteNodes;
    }

    @Override
    public ActionRequestValidationException validate() {
        return null;
";EI_EXPOSE_REP2
"        this.opType = opType;
        this.primaryTerm = primaryTerm;
    }

    public void execute() throws Exception {
        final String activeShardCountFailure = checkActiveShardCount();
        final ShardRouting primaryRouting = primary.routingEntry();
        final ShardId primaryId = primaryRouting.shardId();
        if (activeShardCountFailure != null) {
            finishAsFailed(new UnavailableShardsException(primaryId,
                ""{} Timeout: [{}], request: [{}]"", activeShardCountFailure, request.timeout(), request));
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
        /**
         * @return The replication failures that have been captured in the case writes have failed on replica shards.
         */
        public Failure[] getFailures() {
            return failures;
        }

        public RestStatus status() {
            RestStatus status = RestStatus.OK;
            for (Failure failure : failures) {
";EI_EXPOSE_REP
"        }

        // Implements equals and hashcode for testing
        @Override
        public boolean equals(Object obj) {
            if (obj == null || obj.getClass() != ReplicationTask.Status.class) {
                return false;
            }
            ReplicationTask.Status other = (Status) obj;
            return phase.equals(other.phase);
        }
";EQ_GETCLASS_AND_CLASS_CONSTANT
"        this.indexNameExpressionResolver = indexNameExpressionResolver;
    }

    @Override
    protected void doExecute(Task task, Request request, ActionListener<Response> listener) {
        final ClusterState clusterState = clusterService.state();
        List<ShardId> shards = shards(request, clusterState);
        final CopyOnWriteArrayList<ShardResponse> shardsResponses = new CopyOnWriteArrayList<>();
        if (shards.size() == 0) {
            finishAndNotifyListener(listener, shardsResponses);
        }
";DLS_DEAD_LOCAL_STORE
"                final ReplicaRequest request,
                final long primaryTerm,
                final long globalCheckpoint,
                final long maxSeqNoOfUpdatesOrDeletes,
                final ActionListener<ReplicationOperation.ReplicaResponse> listener) {
            String nodeId = replica.currentNodeId();
            final DiscoveryNode node = clusterService.state().nodes().get(nodeId);
            if (node == null) {
                listener.onFailure(new NoNodeAvailableException(""unknown node ["" + nodeId + ""]""));
                return;
            }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    /** Syncs operation result to the translog or throws a shard not available failure */
    protected static Location syncOperationResultOrThrow(final Engine.Result operationResult,
                                                         final Location currentLocation) throws Exception {
        final Location location;
        if (operationResult.getFailure() != null) {
            // check if any transient write operation failures should be bubbled up
            Exception failure = operationResult.getFailure();
            assert failure instanceof MapperParsingException : ""expected mapper parsing failures. got "" + failure;
            throw failure;
        } else {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
            this.shardIt = shards(clusterState, internalRequest);
        }

        public void start() {
            if (shardIt == null) {
                // just execute it on the local node
                final Writeable.Reader<Response> reader = getResponseReader();
                transportService.sendRequest(clusterService.localNode(), transportShardAction, internalRequest.request(),
                    new TransportResponseHandler<Response>() {
                    @Override
";NP_UNWRITTEN_FIELD
"    public String[] getActions() {
        return actions;
    }

    public final String[] getNodes() {
        return nodes;
    }

    @SuppressWarnings(""unchecked"")
    public final Request setNodes(String... nodes) {
        this.nodes = nodes;
";EI_EXPOSE_REP
"        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
        }
";EQ_DOESNT_OVERRIDE_EQUALS
"            return clusterState.nodes().resolveNodes(request.getNodes());
        }
    }

    protected void processTasks(TasksRequest request, Consumer<OperationTask> operation) {
        if (request.getTaskId().isSet()) {
            // we are only checking one task, we can optimize it
            Task task = taskManager.getTask(request.getTaskId().getId());
            if (task != null) {
                if (request.match(task)) {
                    operation.accept((OperationTask) task);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    private MultiTermVectorsItemResponse[] responses;

    MultiTermVectorsResponse() {
    }

    public MultiTermVectorsResponse(MultiTermVectorsItemResponse[] responses) {
        this.responses = responses;
    }

    public MultiTermVectorsItemResponse[] getResponses() {
        return this.responses;
";EI_EXPOSE_REP2
"        if (numSelectedFields > 0) {
            selectedFields = new HashSet<>();
            for (int i = 0; i < numSelectedFields; i++) {
                selectedFields.add(in.readString());
            }
        }
        if (in.readBoolean()) {
            perFieldAnalyzer = readPerFieldAnalyzer(in.readMap());
        }
        if (in.readBoolean()) {
            filterSettings = new FilterSettings();
";EI_EXPOSE_REP
"    public void writeTo(StreamOutput out) throws IOException {
        out.writeString(index);
        if (out.getVersion().before(Version.V_8_0_0)) {
            // types not supported so send an empty array to previous versions
            out.writeString(MapperService.SINGLE_MAPPING_NAME);
        }
        out.writeString(id);
        out.writeVLong(docVersion);
        final boolean docExists = isExists();
        out.writeBoolean(docExists);
        out.writeBoolean(artificial);
";SA_FIELD_SELF_COMPARISON
"                // HOSTNAME is set by elasticsearch-env and elasticsearch-env.bat so it is always available
                () -> System.getenv(""HOSTNAME""));
    }

    private void start() throws NodeValidationException {
        node.start();
        keepAliveThread.start();
    }

    static void stop() throws IOException {
        try {
";NP_UNWRITTEN_FIELD
"    /**
     * Return a map from codebase name to codebase url of jar codebases used by ES core.
     */
    @SuppressForbidden(reason = ""find URL path"")
    static Map<String, URL> getCodebaseJarMap(Set<URL> urls) {
        Map<String, URL> codebases = new LinkedHashMap<>(); // maintain order
        for (URL url : urls) {
            try {
                String fileName = PathUtils.get(url.toURI()).getFileName().toString();
                if (fileName.endsWith("".jar"") == false) {
                    // tests :(
";NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE
"    public void printStackTrace(PrintWriter s) {
        printStackTrace(s::println);
    }

    private void printStackTrace(Consumer<String> consumer) {
        Throwable originalCause = getCause();
        Throwable cause = originalCause;
        if (cause instanceof CreationException) {
            cause = getFirstGuiceCause((CreationException)cause);
        }

";RCN_REDUNDANT_NULLCHECK_WOULD_HAVE_BEEN_A_NPE
"    public Client filterWithHeader(Map<String, String> headers) {
        return new FilterClient(this) {
            @Override
            protected <Request extends ActionRequest, Response extends ActionResponse>
            void doExecute(ActionType<Response> action, Request request, ActionListener<Response> listener) {
                ThreadContext threadContext = threadPool().getThreadContext();
                try (ThreadContext.StoredContext ctx = threadContext.stashAndMergeHeaders(headers)) {
                    super.doExecute(action, request, listener);
                }
            }
        };
";IA_AMBIGUOUS_INVOCATION_OF_INHERITED_OR_OUTER_METHOD
"    /**
     * Sets the indices the operation needs to be executed on
     */
    @SuppressWarnings(""unchecked"")
    public T indices(Index[] indices) {
        this.indices = indices;
        return (T)this;
    }
}
null
null
";EI_EXPOSE_REP2
"            components.add(""markAsStale ["" + markAsStale + ""]"");
            return String.join("", "", components);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            FailedShardEntry that = (FailedShardEntry) o;
            // Exclude message and exception from equals and hashCode
            return Objects.equals(this.shardId, that.shardId) &&
";EQ_UNUSUAL
"
    /**
     * Returns the shard size for the given shard routing or <code>defaultValue</code> it that metric is not available.
     */
    public long getShardSize(ShardRouting shardRouting, long defaultValue) {
        Long shardSize = getShardSize(shardRouting);
        return shardSize == null ? defaultValue : shardSize;
    }

    /**
     * Method that incorporates the ShardId for the shard into a string that
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        public String toString() {
            return ""VoteCollection{votes="" + nodes.keySet() + "", joins="" + joins + ""}"";
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof VoteCollection)) return false;

            VoteCollection that = (VoteCollection) o;

";EQ_UNUSUAL
"            out.writeLong(term);
            sender.writeTo(out);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            FollowerCheckRequest that = (FollowerCheckRequest) o;
            return term == that.term &&
                Objects.equals(sender, that.sender);
";EQ_UNUSUAL
"        public DiscoveryNode getSender() {
            return sender;
        }

        @Override
        public boolean equals(final Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            final LeaderCheckRequest that = (LeaderCheckRequest) o;
            return Objects.equals(sender, that.sender);
        }
";EQ_UNUSUAL
"            this.currentMaster = currentMaster;
            this.inCurrentConfig = inCurrentConfig;
        }

        @Override
        public int compareTo(VotingConfigNode other) {
            // prefer current master
            final int currentMasterComp = Boolean.compare(other.currentMaster, currentMaster);
            if (currentMasterComp != 0) {
                return currentMasterComp;
            }
";EQ_COMPARETO_USE_OBJECT_EQUALS
"        return new AliasMetaData(aliasMetaData, newAlias);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        final AliasMetaData that = (AliasMetaData) o;

        if (alias != null ? !alias.equals(that.alias) : that.alias != null) return false;
";RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN
"        this.roles = Set.copyOf(roles);
    }

    /** Creates a DiscoveryNode representing the local node. */
    public static DiscoveryNode createLocal(Settings settings, TransportAddress publishAddress, String nodeId) {
        Map<String, String> attributes = Node.NODE_ATTRIBUTES.getAsMap(settings);
        Set<DiscoveryNodeRole> roles = getRolesFromSettings(settings);
        return new DiscoveryNode(Node.NODE_NAME_SETTING.get(settings), nodeId, publishAddress, attributes, roles, Version.CURRENT);
    }

    /** extract node roles from the given settings */
";DLS_DEAD_LOCAL_STORE
"        }
        return false;
    }

    public boolean match(DiscoveryNode node) {
        for (Map.Entry<String, String[]> entry : filters.entrySet()) {
            String attr = entry.getKey();
            String[] values = entry.getValue();
            if (""_ip"".equals(attr)) {
                // We check both the host_ip or the publish_ip
                String publishAddress = null;
";BC_VACUOUS_INSTANCEOF
"    }

    protected abstract Setting<Boolean> roleSetting();

    @Override
    public final boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DiscoveryNodeRole that = (DiscoveryNodeRole) o;
        return roleName.equals(that.roleName) &&
            roleNameAbbreviation.equals(that.roleNameAbbreviation) &&
";EQ_UNUSUAL
"        /**
         * adds a disco node to the builder. Will throw an {@link IllegalArgumentException} if
         * the supplied node doesn't pass the pre-flight checks performed by {@link #validateAdd(DiscoveryNode)}
         */
        public Builder add(DiscoveryNode node) {
            final String preflight = validateAdd(node);
            if (preflight != null) {
                throw new IllegalArgumentException(preflight);
            }
            putUnsafe(node);
            return this;
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    @Override
    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {
        final DiscoveryNode discoNode;
        try {
            discoNode = allocation.nodes().resolveNode(node);
        } catch (IllegalArgumentException e) {
            return explainOrThrowRejectedCommand(explain, allocation, e);
        }
        final RoutingNodes routingNodes = allocation.routingNodes();
        RoutingNode routingNode = routingNodes.node(discoNode.getId());
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    @Override
    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {
        final DiscoveryNode discoNode;
        try {
            discoNode = allocation.nodes().resolveNode(node);
        } catch (IllegalArgumentException e) {
            return explainOrThrowRejectedCommand(explain, allocation, e);
        }
        final RoutingNodes routingNodes = allocation.routingNodes();
        RoutingNode routingNode = routingNodes.node(discoNode.getId());
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    @Override
    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {
        final DiscoveryNode discoNode;
        try {
            discoNode = allocation.nodes().resolveNode(node);
        } catch (IllegalArgumentException e) {
            return explainOrThrowRejectedCommand(explain, allocation, e);
        }
        final RoutingNodes routingNodes = allocation.routingNodes();
        RoutingNode routingNode = routingNodes.node(discoNode.getId());
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return this.toNode;
    }

    @Override
    public RerouteExplanation execute(RoutingAllocation allocation, boolean explain) {
        DiscoveryNode fromDiscoNode = allocation.nodes().resolveNode(fromNode);
        DiscoveryNode toDiscoNode = allocation.nodes().resolveNode(toNode);
        Decision decision = null;

        boolean found = false;
        RoutingNode fromRoutingNode = allocation.routingNodes().node(fromDiscoNode.getId());
";RV_RETURN_VALUE_IGNORED_NO_SIDE_EFFECT
"
    public static final String NAME = ""node_version"";

    @Override
    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {
        if (shardRouting.primary()) {
            if (shardRouting.currentNodeId() == null) {
                if (shardRouting.recoverySource() != null && shardRouting.recoverySource().getType() == RecoverySource.Type.SNAPSHOT) {
                    // restoring from a snapshot - check that the node can handle the version
                    return isVersionCompatible((SnapshotRecoverySource)shardRouting.recoverySource(), node, allocation);
                } else {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return canAllocate(shardRouting, allocation);
    }

    @Override
    public Decision canAllocate(ShardRouting shardRouting, RoutingAllocation allocation) {
        if (shardRouting.primary()) {
            return allocation.decision(Decision.YES, NAME, ""shard is primary and can be allocated"");
        }
        ShardRouting primary = allocation.routingNodes().activePrimary(shardRouting.shardId());
        if (primary == null) {
            return allocation.decision(Decision.NO, NAME, ""primary shard for this replica is not yet active"");
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return canAllocate(shardRouting, null, allocation);
    }

    @Override
    public Decision canAllocate(ShardRouting shardRouting, RoutingNode node, RoutingAllocation allocation) {
        final UnassignedInfo unassignedInfo = shardRouting.unassignedInfo();
        if (unassignedInfo != null && shardRouting.recoverySource().getType() == RecoverySource.Type.LOCAL_SHARDS) {
            // we only make decisions here if we have an unassigned info and we have to recover from another index ie. split / shrink
            final IndexMetaData indexMetaData = allocation.metaData().getIndexSafe(shardRouting.index());
            Index resizeSourceIndex = indexMetaData.getResizeSourceIndex();
            assert resizeSourceIndex != null;
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"     * @param newRoutingTable {@link RoutingTable} object after routing changes were applied.
     * @return adapted {@link MetaData}, potentially the original one if no change was needed.
     */
    public MetaData applyChanges(MetaData oldMetaData, RoutingTable newRoutingTable) {
        Map<Index, List<Map.Entry<ShardId, Updates>>> changesGroupedByIndex =
            shardChanges.entrySet().stream().collect(Collectors.groupingBy(e -> e.getKey().getIndex()));

        MetaData.Builder metaDataBuilder = null;
        for (Map.Entry<Index, List<Map.Entry<ShardId, Updates>>> indexChanges : changesGroupedByIndex.entrySet()) {
            Index index = indexChanges.getKey();
            final IndexMetaData oldIndexMetaData = oldMetaData.getIndexSafe(index);
";RCN_REDUNDANT_NULLCHECK_OF_NULL_VALUE
"        return builder;
    }

    @Override
    public int compareTo(NodeAllocationResult other) {
        return nodeResultComparator.compare(this, other);
    }

    /** A class that captures metadata about a shard store on a node. */
    public static final class ShardStoreInfo implements ToXContentFragment, Writeable {
        private final boolean inSync;
";EQ_COMPARETO_USE_OBJECT_EQUALS
"    /**
     * Returns the total number of shards plus the number of empty groups
     * @return number of shards and empty groups
     */
    public int totalSizeWith1ForEmpty() {
        int size = 0;
        for (ShardIt shard : iterators) {
            size += Math.max(1, shard.size());
        }
        return size;
    }
";NP_UNWRITTEN_FIELD
"        }
        return shardRoutings;
    }

    private static List<ShardRouting> collectAttributeShards(AttributesKey key, DiscoveryNodes nodes, ArrayList<ShardRouting> from) {
        final ArrayList<ShardRouting> to = new ArrayList<>();
        for (final String attribute : key.attributes) {
            final String localAttributeValue = nodes.getLocalNode().getAttributes().get(attribute);
            if (localAttributeValue != null) {
                for (Iterator<ShardRouting> iterator = from.iterator(); iterator.hasNext(); ) {
                    ShardRouting fromShard = iterator.next();
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"     * @param indexRouting IndexRoutingTable
     * @param shardId ShardId
     * @return IndexShardRoutingTable
     */
    public static IndexShardRoutingTable shardRoutingTable(IndexRoutingTable indexRouting, int shardId) {
        IndexShardRoutingTable indexShard = indexRouting.shard(shardId);
        if (indexShard == null) {
            throw new ShardNotFoundException(new ShardId(indexRouting.getIndex(), shardId));
        }
        return indexShard;
    }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    public static NamedDiff<Custom> readDiffFrom(StreamInput in) throws IOException {
        return readDiffFrom(Custom.class, TYPE, in);
    }

    public SnapshotsInProgress(StreamInput in) throws IOException {
        Entry[] entries = new Entry[in.readVInt()];
        for (int i = 0; i < entries.length; i++) {
            Snapshot snapshot = new Snapshot(in);
            boolean includeGlobalState = in.readBoolean();
            boolean partial = in.readBoolean();
";UC_USELESS_OBJECT
"        return unmodifiableMap(builder);
    }

    @Override
    public Map<String, BlobMetaData> listBlobsByPrefix(String blobNamePrefix) throws IOException {
        Map<String, BlobMetaData> builder = new HashMap<>();

        blobNamePrefix = blobNamePrefix == null ? """" : blobNamePrefix;
        try (DirectoryStream<Path> stream = Files.newDirectoryStream(path, blobNamePrefix + ""*"")) {
            for (Path file : stream) {
                final BasicFileAttributes attrs = Files.readAttributes(file, BasicFileAttributes.class);
";NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE
"     * have to be copied.
     *
     * @return the bytes ref
     */
    @Override
    public BytesRef toBytesRef() {
        if (buffer.hasArray()) {
            return new BytesRef(buffer.array(), buffer.arrayOffset(), length);
        }
        final byte[] copy = new byte[length];
        buffer.get(copy, 0, length);
";IL_INFINITE_RECURSIVE_LOOP
"            this.mark = input.getOffset();
        }

        @Override
        public long skip(long n) throws IOException {
            return input.skip(n);
        }
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
";NP_UNWRITTEN_FIELD
"    }


    @Override
    public byte get(int index) {
        final int i = getOffsetIndex(index);
        return references[i].get(index - offsets[i]);
    }

    @Override
    public int length() {
";NP_UNWRITTEN_FIELD
"        }
        return new PagedBytesReference(byteArray, offset + from, length);
    }

    @Override
    public BytesRef toBytesRef() {
        BytesRef bref = new BytesRef();
        // if length <= pagesize this will dereference the page, or materialize the byte[]
        byteArray.get(offset, length, bref);
        return bref;
    }
";IL_INFINITE_RECURSIVE_LOOP
"            return next != null;
        }

        @Override
        public Entry<K, V> next() {
            current = next;
            next = next.after;
            return current;
        }

        @Override
";IT_NO_SUCH_ELEMENT
"        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        ImmutableOpenIntMap that = (ImmutableOpenIntMap) o;

        if (!map.equals(that.map)) return false;

        return true;
    }

    @Override
";EQ_UNUSUAL
"        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        ImmutableOpenMap that = (ImmutableOpenMap) o;

        if (!map.equals(that.map)) return false;

        return true;
    }

    @Override
";EQ_UNUSUAL
"
    /**
     * Create a {@link CompressedXContent} out of a serialized {@link ToXContent}
     * that may already be compressed.
     */
    public CompressedXContent(BytesReference data) throws IOException {
        Compressor compressor = CompressorFactory.compressor(data);
        if (compressor != null) {
            // already compressed...
            this.bytes = BytesReference.toBytes(data);
            this.crc32 = crc32(new BytesArray(uncompressed()));
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    /**
     * Uncompress the provided data, data can be detected as compressed using {@link #isCompressed(BytesReference)}.
     * @throws NullPointerException a NullPointerException will be thrown when bytes is null
     */
    public static BytesReference uncompressIfNeeded(BytesReference bytes) throws IOException {
        Compressor compressor = compressor(Objects.requireNonNull(bytes, ""the BytesReference must not be null""));
        BytesReference uncompressed;
        if (compressor != null) {
            uncompressed = uncompress(bytes, compressor);
        } else {
            uncompressed = bytes;
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        FieldMemoryStats that = (FieldMemoryStats) o;
        return Objects.equals(stats, that.stats);
    }

    @Override
    public int hashCode() {
        return Objects.hash(stats);
";EQ_UNUSUAL
"        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        CircleBuilder other = (CircleBuilder) obj;
        return Objects.equals(center, other.center) &&
                Objects.equals(radius, other.radius) &&
                Objects.equals(unit.ordinal(), other.unit.ordinal());
    }
}
null
";EQ_UNUSUAL
"        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        EnvelopeBuilder other = (EnvelopeBuilder) obj;
        return Objects.equals(topLeft, other.topLeft) &&
                Objects.equals(bottomRight, other.bottomRight);
    }
}
null
null
";EQ_UNUSUAL
"    public int hashCode() {
        return Objects.hash(shapes);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
";EQ_UNUSUAL
"    public int hashCode() {
        return Objects.hash(lines);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
";EQ_UNUSUAL
"    public int hashCode() {
        return Objects.hash(polygons, orientation);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
";EQ_UNUSUAL
"    public int hashCode() {
        return Objects.hash(shell, holes, orientation);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null || getClass() != obj.getClass()) {
            return false;
";EQ_UNUSUAL
"        if (this == o) return true;
        if (!(o instanceof ShapeBuilder)) return false;

        ShapeBuilder<?,?,?> that = (ShapeBuilder<?,?,?>) o;

        return Objects.equals(coordinates, that.coordinates);
    }

    @Override
    public int hashCode() {
        return Objects.hash(coordinates);
";EQ_UNUSUAL
"        }

        @Override
        CoordinateNode validate(CoordinateNode coordinates, boolean coerce) {
            // validate the coordinate array for envelope type
            if (coordinates.children.size() != 2) {
                throw new ElasticsearchParseException(
                    ""invalid number of points [{}] provided for geo_shape [{}] when expecting an array of 2 coordinates"",
                    coordinates.children.size(), GeoShapeType.ENVELOPE.shapename);
            }
            return coordinates;
";NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD
"                public boolean advanceExact(int doc) throws IOException {
                    return singleValues.advanceExact(doc);
                }

                @Override
                public double doubleValue() throws IOException {
                    final GeoPoint from = fromPoints[0];
                    final GeoPoint to = singleValues.geoPointValue();
                    return distance.calculate(from.lat(), from.lon(), to.lat(), to.lon(), unit);
                }

";UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS
"     * Note, this hashing function might be used to persist hashes, so if the way hashes are computed
     * changes for some reason, it needs to be addressed (like in BloomFilter and MurmurHashField).
     */
    @SuppressWarnings(""fallthrough"") // Intentionally uses fallthrough to implement a well known hashing algorithm
    public static Hash128 hash128(byte[] key, int offset, int length, long seed, Hash128 hash) {
        long h1 = seed;
        long h2 = seed;

        if (length >= 16) {

            final int len16 = length & 0xFFFFFFF0; // higher multiple of 16 that is lower than or equal to length
";SF_SWITCH_NO_DEFAULT
"            return MoreTypes.isFullySpecified(upperBound)
                    && (lowerBound == null || MoreTypes.isFullySpecified(lowerBound));
        }

        @Override
        public boolean equals(Object other) {
            return other instanceof WildcardType
                    && MoreTypes.equals(this, (WildcardType) other);
        }

        @Override
";EQ_UNUSUAL
"null
null
null
null
null
null
null
null
null
null
null
";SF_SWITCH_NO_DEFAULT
"    public Message(Object source, String message) {
        this(Collections.singletonList(source), message, null);
    }

    public Message(Object source, Throwable cause) {
        this(Collections.singletonList(source), null, cause);
    }

    public Message(String message) {
        this(Collections.emptyList(), message, null);
    }
";NP_NULL_PARAM_DEREF_NONVIRTUAL
"    public int hashCode() {
        return Objects.hash(locale(), zone(), pattern());
    }

    @Override
    public boolean equals(Object obj) {
        if (obj.getClass().equals(this.getClass()) == false) {
            return false;
        }
        JodaDateFormatter other = (JodaDateFormatter) obj;

";EQ_UNUSUAL
"        sb.append(""])"");
        return sb.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (sameClassAs(o) == false) {
            return false;
";EQ_UNUSUAL
"        sb.append(""{"" + (function == null ? """" : function.toString()) + ""}"");
        return sb.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (sameClassAs(o) == false) {
            return false;
";EQ_UNUSUAL
"                maxDocFreq, maxQueryTerms, maxWordLen, minDocFreq, minTermFrequency, minWordLen,
                Arrays.hashCode(moreLikeFields), minimumShouldMatch, stopWords);
    }

    @Override
    public boolean equals(Object obj) {
        if (sameClassAs(obj) == false) {
            return false;
        }
        MoreLikeThisQuery other = (MoreLikeThisQuery) obj;
        if (!analyzer.equals(other.analyzer))
";EQ_UNUSUAL
"
    /**
     * Returns true if <code>o</code> is equal to this.
     */
    @Override
    public boolean equals(Object o) {
        if (sameClassAs(o) == false) {
            return false;
        }
        MultiPhrasePrefixQuery other = (MultiPhrasePrefixQuery) o;
        return this.slop == other.slop
";EQ_UNUSUAL
"    /**
     * Constructs a new SecureString which controls the passed in char array.
     *
     * Note: When this instance is closed, the array will be zeroed out.
     */
    public SecureString(char[] chars) {
        this.chars = Objects.requireNonNull(chars);
    }

    /**
     * Constructs a new SecureString from an existing String.
";EI_EXPOSE_REP2
"            this.defaultStringValue = defaultStringValue;
        }

        @Override
        String innerGetRaw(final Settings settings) {
            List<String> array = settings.getAsList(getKey(), null);
            return array == null ? defaultValue.apply(settings) : arrayToParsableString(array);
        }

        @Override
        boolean hasComplexMatcher() {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        }
        return sb.toString();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Settings that = (Settings) o;
        return Objects.equals(settings, that.settings);
";EQ_UNUSUAL
"    public static boolean isValidPattern(String pattern) {
        return AbstractScopedSettings.isValidKey(pattern) || Regex.isSimpleMatchPattern(pattern);
    }

    public void addFilterSettingParams(RestRequest request) {
        if (patterns.isEmpty() == false) {
            request.params().put(SETTINGS_FILTER_PARAM, patternString);
        }
    }

    public static Settings filterSettings(Params params, Settings settings) {
";NP_UNWRITTEN_FIELD
"     * @param s         the string to split
     * @param separator the separator to split on
     * @param decode    decode backslash escaping
     */
    public static List<String> splitSmart(String s, String separator, boolean decode) {
        ArrayList<String> lst = new ArrayList<>(2);
        StringBuilder sb = new StringBuilder();
        int pos = 0, end = s.length();
        while (pos < end) {
            if (s.startsWith(separator, pos)) {
                if (sb.length() > 0) {
";SF_SWITCH_NO_DEFAULT
"
package org.elasticsearch.common.time;

import org.apache.logging.log4j.LogManager;
import org.elasticsearch.common.logging.DeprecationLogger;
import org.joda.time.DateTimeZone;

import java.time.Clock;
import java.time.Duration;
import java.time.Instant;
import java.time.ZoneId;
";RV_RETURN_VALUE_IGNORED_INFERRED
"        return Objects.hash(locale(), printer.getZone(), format);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj.getClass().equals(this.getClass()) == false) {
            return false;
        }
        JavaDateFormatter other = (JavaDateFormatter) obj;

        return Objects.equals(format, other.format) &&
";NP_EQUALS_SHOULD_HANDLE_NULL_ARGUMENT
"    private TransportAddress publishAddress;

    BoundTransportAddress() {
    }

    public BoundTransportAddress(TransportAddress[] boundAddresses, TransportAddress publishAddress) {
        if (boundAddresses == null || boundAddresses.length < 1) {
            throw new IllegalArgumentException(""at least one bound address must be provided"");
        }
        this.boundAddresses = boundAddresses;
        this.publishAddress = publishAddress;
";EI_EXPOSE_REP2
"                    initialInput);
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
";EQ_UNUSUAL
"    public static <E> ArrayList<E> newSingletonArrayList(E element) {
        return new ArrayList<>(Collections.singletonList(element));
    }

    public static <E> List<List<E>> eagerPartition(List<E> list, int size) {
        if (list == null) {
            throw new NullPointerException(""list"");
        }
        if (size <= 0) {
            throw new IllegalArgumentException(""size <= 0"");
        }
";ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL
"            rescheduleIfNecessary();
        }
    }

    public TimeValue getInterval() {
        return interval;
    }

    /**
     * Test any external conditions that determine whether the task
     * should be scheduled.  This method does *not* need to test if
";UG_SYNC_SET_UNSYNC_GET
"            this.insertionOrder = insertionOrder;
        }

        @Override
        public int compareTo(PrioritizedFutureTask pft) {
            int res = priority.compareTo(pft.priority);
            if (res != 0) {
                return res;
            }
            return insertionOrder < pft.insertionOrder ? -1 : 1;
        }
";EQ_COMPARETO_USE_OBJECT_EQUALS
"    public int hashCode() {
        return Objects.hash(numBuckets, bitsPerEntry, entriesPerBucket, count, evictedFingerprint);
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (other == null || getClass() != other.getClass()) {
            return false;
";EQ_UNUSUAL
"        return values.get(bucket) != null;
    }

    @Override
    protected void removeAndAdd(long index) {
        final long key = keys.get(index);
        final T value = values.set(index, null);
        --size;
        final T removed = set(key, value);
        assert removed == null;
    }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return extractValue(pathElements, 0, map);
    }

    @SuppressWarnings({""unchecked""})
    private static Object extractValue(String[] pathElements, int index, Object currentValue) {
        if (index == pathElements.length) {
            return currentValue;
        }
        if (currentValue == null) {
            return null;
        }
";SBSC_USE_STRINGBUFFER_CONCATENATION
"     * Writes a ""raw"" (bytes) field, handling cases where the bytes are compressed, and tries to optimize writing using
     * {@link XContentBuilder#rawField(String, InputStream, XContentType)}.
     */
    public static void writeRawField(String field, BytesReference source, XContentType xContentType, XContentBuilder builder,
                                     ToXContent.Params params) throws IOException {
        Objects.requireNonNull(xContentType);
        Compressor compressor = CompressorFactory.compressor(source);
        if (compressor != null) {
            try (InputStream compressedStreamInput = compressor.streamInput(source.streamInput())) {
                builder.rawField(field, compressedStreamInput, xContentType);
            }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    /**
     * Parses the output of {@link #generateFailureXContent(XContentBuilder, Params, Exception, boolean)}
     */
    public static ElasticsearchException failureFromXContent(XContentParser parser) throws IOException {
        XContentParser.Token token = parser.currentToken();
        ensureFieldName(parser, token, ERROR);

        token = parser.nextToken();
        if (token.isValue()) {
            return new ElasticsearchException(buildMessage(""exception"", parser.text(), null));
";DLS_DEAD_LOCAL_STORE
"
    /**
     * The shared filesystem repo locations.
     */
    public Path[] repoFiles() {
        return repoFiles;
    }

    /**
     * Resolves the specified location against the list of configured repository roots
     *
";EI_EXPOSE_REP
"            this.reason = cause.getMessage();
            this.causeType = cause.getClass();
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
";EQ_UNUSUAL
"    /**
     * Finds the store for the assigned shard in the fetched data, returns null if none is found.
     */
    private static TransportNodesListShardStoreMetaData.StoreFilesMetaData findStore(ShardRouting shard, RoutingAllocation allocation,
            AsyncShardFetch.FetchResult<NodeStoreFilesMetaData> data) {
        assert shard.currentNodeId() != null;
        DiscoveryNode primaryNode = allocation.nodes().get(shard.currentNodeId());
        if (primaryNode == null) {
            return null;
        }
        NodeStoreFilesMetaData primaryNodeFilesStore = data.getData().get(primaryNode);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        this.analysisMode = mode;
    }

    static AnalyzerComponents createComponents(String name, Settings analyzerSettings, final Map<String, TokenizerFactory> tokenizers,
            final Map<String, CharFilterFactory> charFilters, final Map<String, TokenFilterFactory> tokenFilters) {
        String tokenizerName = analyzerSettings.get(""tokenizer"");
        if (tokenizerName == null) {
            throw new IllegalArgumentException(""Custom Analyzer ["" + name + ""] must be configured with a tokenizer"");
        }

        TokenizerFactory tokenizer = tokenizers.get(tokenizerName);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            throw new IllegalStateException(""NamedAnalyzer cannot be wrapped with a wrapper, only a delegator"");
        }
    };

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof NamedAnalyzer)) return false;
        NamedAnalyzer that = (NamedAnalyzer) o;
        return Objects.equals(name, that.name);
    }
";EQ_UNUSUAL
"        super(indexSettings, settings, name);
        maxTokenLength = settings.getAsInt(""max_token_length"", StandardAnalyzer.DEFAULT_MAX_TOKEN_LENGTH);
    }

    @Override
    public Tokenizer create() {
        StandardTokenizer tokenizer = new StandardTokenizer();
        tokenizer.setMaxTokenLength(maxTokenLength);
        return tokenizer;
    }
}
";IL_INFINITE_RECURSIVE_LOOP
"        }

        @Override
        public boolean equals(Object o) {
            if (!(o instanceof QueryWrapperBitSetProducer)) return false;
            return this.query.equals(((QueryWrapperBitSetProducer) o).query);
        }

        @Override
        public int hashCode() {
            return 31 * getClass().hashCode() + query.hashCode();
";EQ_UNUSUAL
"        numDocs = in.readInt();
    }

    @Override
    public void writeTo(StreamOutput out) throws IOException {
        out.writeVInt(userData.size());
        for (Map.Entry<String, String> entry : userData.entrySet()) {
            out.writeString(entry.getKey());
            out.writeString(entry.getValue());
        }
        out.writeLong(generation);
";NP_UNWRITTEN_FIELD
"    public long ramBytesUsed() {
        return BASE_RAM_BYTES_USED;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;

        DeleteVersionValue that = (DeleteVersionValue) o;
";EQ_UNUSUAL
"        public boolean idsEqual(byte[] id) {
            return Arrays.equals(id, this.id);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
";EQ_UNUSUAL
"    public long ramBytesUsed() {
        return RAM_BYTES_USED + RamUsageEstimator.shallowSizeOf(translogLocation);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        IndexVersionValue that = (IndexVersionValue) o;
        return Objects.equals(translogLocation, that.translogLocation);
";EQ_UNUSUAL
"    public Map<String, String> getAttributes() {
        return attributes;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Segment segment = (Segment) o;

";EQ_UNUSUAL
"    public Collection<Accountable> getChildResources() {
        return Collections.emptyList();
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        VersionValue that = (VersionValue) o;

";EQ_UNUSUAL
"                }
                return true;
            }

            @Override
            public double doubleValue() throws IOException {
                return value;
            }
        };
    }
}
";UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS
"        this.maxFrequency = maxFrequency;
        this.minSegmentSize = minSegmentSize;
    }

    @Override
    public OrdinalMap getOrdinalMap() {
        return null;
    }

    @Override
    public IndexOrdinalsFieldData loadGlobal(DirectoryReader indexReader) {
";IL_INFINITE_RECURSIVE_LOOP
"    AbstractLatLonPointDVIndexFieldData(Index index, String fieldName) {
        super(index, fieldName);
    }

    @Override
    public SortField sortField(@Nullable Object missingValue, MultiValueMode sortMode, XFieldComparatorSource.Nested nested,
            boolean reverse) {
        throw new IllegalArgumentException(""can't sort on geo_point field without using specific sorting feature, like geo_distance"");
    }

    public static class LatLonPointDVIndexFieldData extends AbstractLatLonPointDVIndexFieldData {
";IL_INFINITE_RECURSIVE_LOOP
"    public BinaryDVAtomicFieldData loadDirect(LeafReaderContext context) throws Exception {
        return load(context);
    }

    @Override
    public SortField sortField(@Nullable Object missingValue, MultiValueMode sortMode, XFieldComparatorSource.Nested nested,
            boolean reverse) {
        XFieldComparatorSource source = new BytesRefFieldComparatorSource(this, missingValue, sortMode, nested);
        /**
         * Check if we can use a simple {@link SortedSetSortField} compatible with index sorting and
         * returns a custom sort field otherwise.
";IL_INFINITE_RECURSIVE_LOOP
"    public BytesBinaryDVIndexFieldData(Index index, String fieldName) {
        super(index, fieldName);
    }

    @Override
    public SortField sortField(@Nullable Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {
        throw new IllegalArgumentException(""can't sort on binary field"");
    }

    @Override
    public BytesBinaryDVAtomicFieldData load(LeafReaderContext context) {
";IL_INFINITE_RECURSIVE_LOOP
"        sortField.setMissingValue(source.missingObject(missingValue, reverse));
        return sortField;
    }

    @Override
    public SortField sortField(Object missingValue, MultiValueMode sortMode, Nested nested, boolean reverse) {
        return sortField(numericType, missingValue, sortMode, nested, reverse);
    }

    @Override
    public NumericType getNumericType() {
";IL_INFINITE_RECURSIVE_LOOP
"
    /**
     * The source of the document if exists.
     */
    public byte[] source() {
        if (source == null) {
            return null;
        }
        if (sourceAsBytes != null) {
            return sourceAsBytes;
        }
";EI_EXPOSE_REP
"            this.maxSourceCharsToLog = maxSourceCharsToLog;
        }

        @Override
        public String toString() {
            StringBuilder sb = new StringBuilder();
            sb.append(index).append("" "");
            sb.append(""took["").append(TimeValue.timeValueNanos(tookInNanos)).append(""], "");
            sb.append(""took_millis["").append(TimeUnit.NANOSECONDS.toMillis(tookInNanos)).append(""], "");
            sb.append(""type["").append(doc.type()).append(""], "");
            sb.append(""id["").append(doc.id()).append(""], "");
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    /**
     * Returns <code>true</code> if the index has a custom data path
     */
    public boolean hasCustomDataPath() {
        return customDataPath() != null;
    }

    /**
     * Returns the customDataPath for this index, if configured. <code>null</code> o.w.
     */
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            super(ref);
            this.orientation = ref.orientation;
        }

        @Override
        public boolean equals(Object o) {
            if (!super.equals(o)) return false;
            BaseGeoShapeFieldType that = (BaseGeoShapeFieldType) o;
            return orientation == that.orientation;
        }

";EQ_UNUSUAL
"                    fuzziness.asDistance(), transpositions, nonFuzzyPrefixLength, minFuzzyPrefixLength,
                    unicodeAware, maxExpansions);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            if (!super.equals(o)) return false;

            CompletionFieldType that = (CompletionFieldType) o;
";EQ_UNUSUAL
"        public MappedFieldType clone() {
            return new DateFieldType(this);
        }

        @Override
        public boolean equals(Object o) {
            if (!super.equals(o)) return false;
            DateFieldType that = (DateFieldType) o;
            return Objects.equals(dateTimeFormatter, that.dateTimeFormatter) && Objects.equals(resolution, that.resolution);
        }

";EQ_UNUSUAL
"        return this.indexAnalyzer;
    }

    @Override
    public Iterator<Mapper> iterator() {
        return fieldMappers.values().iterator();
    }
}
null
null
null
";NP_UNWRITTEN_FIELD
"
        private Map<String, Object> meta;

        private final Mapper.BuilderContext builderContext;

        public Builder(RootObjectMapper.Builder builder, MapperService mapperService) {
            final Settings indexSettings = mapperService.getIndexSettings().getSettings();
            this.builderContext = new Mapper.BuilderContext(indexSettings, new ContentPath(1));
            this.rootObjectMapper = builder.build(builderContext);

            final String type = rootObjectMapper.name();
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            throw new MapperParsingException(message + getRemainingFields(fieldNodeMap));
        }
    }

    private static String getRemainingFields(Map<?, ?> map) {
        StringBuilder remainingFields = new StringBuilder();
        for (Object key : map.keySet()) {
            remainingFields.append("" ["").append(key).append("" : "").append(map.get(key)).append(""]"");
        }
        return remainingFields.toString();
    }
";WMI_WRONG_MAP_ITERATOR
"            + currentFieldName + ""]"");
    }

    private static void parseDynamicValue(final ParseContext context, ObjectMapper parentMapper,
                                          String currentFieldName, XContentParser.Token token) throws IOException {
        ObjectMapper.Dynamic dynamic = dynamicOrDefault(parentMapper, context);
        if (dynamic == ObjectMapper.Dynamic.STRICT) {
            throw new StrictDynamicMappingException(parentMapper.fullPath(), currentFieldName);
        }
        if (dynamic == ObjectMapper.Dynamic.FALSE) {
            return;
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        public FieldNamesFieldType clone() {
            return new FieldNamesFieldType(this);
        }

        @Override
        public boolean equals(Object o) {
            if (!super.equals(o)) return false;
            FieldNamesFieldType that = (FieldNamesFieldType) o;
            return enabled == that.enabled;
        }

";EQ_UNUSUAL
"        }
    }

    @Override
    public void parse(ParseContext context) throws IOException {
        context.path().add(simpleName());

        try {
            GeoPoint sparse = context.parseExternalValue(GeoPoint.class);

            if (sparse != null) {
";REC_CATCH_EXCEPTION
"            public SortedBinaryDocValues getBytesValues() {
                SortedBinaryDocValues inValues = in.getBytesValues();
                return new SortedBinaryDocValues() {

                    @Override
                    public BytesRef nextValue() throws IOException {
                        BytesRef encoded = inValues.nextValue();
                        return new BytesRef(Uid.decodeId(
                                Arrays.copyOfRange(encoded.bytes, encoded.offset, encoded.offset + encoded.length)));
                    }

";IL_INFINITE_RECURSIVE_LOOP
"        public KeywordFieldType clone() {
            return new KeywordFieldType(this);
        }

        @Override
        public boolean equals(Object o) {
            if (super.equals(o) == false) {
                return false;
            }
            KeywordFieldType other = (KeywordFieldType) o;
            return Objects.equals(normalizer, other.normalizer) &&
";EQ_UNUSUAL
"        public GeoShapeFieldType clone() {
            return new GeoShapeFieldType(this);
        }

        @Override
        public boolean equals(Object o) {
            if (!super.equals(o)) return false;
            GeoShapeFieldType that = (GeoShapeFieldType) o;
            return treeLevels == that.treeLevels &&
                precisionInMeters == that.precisionInMeters &&
                defaultDistanceErrorPct == that.defaultDistanceErrorPct &&
";EQ_UNUSUAL
"    public IndexFieldData.Builder fielddataBuilder(String fullyQualifiedIndexName) {
        throw new IllegalArgumentException(""Fielddata is not supported on field ["" + name() + ""] of type ["" + typeName() + ""]"");
    }

    @Override
    public boolean equals(Object o) {
        if (!super.equals(o)) return false;
        MappedFieldType fieldType = (MappedFieldType) o;

        return boost == fieldType.boost &&
            docValues == fieldType.docValues &&
";EQ_UNUSUAL
"    final RootObjectMapper root;
    final MetadataFieldMapper[] metadataMappers;
    final Map<Class<? extends MetadataFieldMapper>, MetadataFieldMapper> metadataMappersMap;
    final Map<String, Object> meta;

    public Mapping(Version indexCreated, RootObjectMapper rootObjectMapper,
                   MetadataFieldMapper[] metadataMappers, Map<String, Object> meta) {
        this.indexCreated = indexCreated;
        this.metadataMappers = metadataMappers;
        Map<Class<? extends MetadataFieldMapper>, MetadataFieldMapper> metadataMappersMap = new HashMap<>();
        for (MetadataFieldMapper metadataMapper : metadataMappers) {
";EI_EXPOSE_REP2
"                long v = parse(value, true);
                return LongPoint.newExactQuery(field, v);
            }

            @Override
            public Query termsQuery(String field, List<Object> values) {
                long[] v = new long[values.size()];
                int upTo = 0;

                for (int i = 0; i < values.size(); i++) {
                    Object value = values.get(i);
";IL_INFINITE_RECURSIVE_LOOP
"        public MapperService mapperService() {
            return in.mapperService();
        }

        @Override
        public Field version() {
            return in.version();
        }

        @Override
        public void version(Field version) {
";IL_INFINITE_RECURSIVE_LOOP
"            @Override
            public Long maxValue() {
                return Long.MAX_VALUE;
            }
            @Override
            public Long nextUp(Object value) {
                return ((Number)value).longValue() + 1;
            }
            @Override
            public Long nextDown(Object value) {
                return ((Number)value).longValue() - 1;
";UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS
"         * @param omb Builder whose children to check.
         * @param parentIncluded True iff node is a child of root or a node that is included in
         * root
         */
        private static void fixRedundantIncludes(ObjectMapper.Builder omb, boolean parentIncluded) {
            for (Object mapper : omb.mappersBuilders) {
                if (mapper instanceof ObjectMapper.Builder) {
                    ObjectMapper.Builder child = (ObjectMapper.Builder) mapper;
                    Nested nested = child.nested;
                    boolean isNested = nested.isNested();
                    boolean includeInRootViaParent = parentIncluded && isNested && nested.isIncludeInParent();
";NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD
"            this.enabled = enabled;
            return this;
        }

        public Builder includes(String[] includes) {
            this.includes = includes;
            return this;
        }

        public Builder excludes(String[] excludes) {
            this.excludes = excludes;
";EI_EXPOSE_REP2
"        public TextFieldType clone() {
            return new TextFieldType(this);
        }

        @Override
        public boolean equals(Object o) {
            if (super.equals(o) == false) {
                return false;
            }
            TextFieldType that = (TextFieldType) o;
            return fielddata == that.fielddata
";EQ_UNUSUAL
"            }
            return new TermInSetQuery(CONTENT_TYPE, types);
        }

        @Override
        public boolean equals(Object obj) {
            if (sameClassAs(obj) == false) {
                return false;
            }
            TypesQuery that = (TypesQuery) obj;
            return Arrays.equals(types, that.types);
";EQ_UNUSUAL
"            builder.field(NAME_FIELD.getPreferredName(), queryName);
        }
    }

    @Override
    public final Query toQuery(QueryShardContext context) throws IOException {
        Query query = doToQuery(context);
        if (query != null) {
            if (boost != DEFAULT_BOOST) {
                if (query instanceof SpanQuery) {
                    query = new SpanBoostQuery((SpanQuery) query, boost);
";IL_INFINITE_RECURSIVE_LOOP
"        Object origin() {
            return origin;
        }

        @Override
        public final boolean equals(Object other) {
            if ((other instanceof Origin) == false) return false;
            Object otherOrigin = ((Origin) other).origin();
            return this.origin().equals(otherOrigin);
        }

";EQ_UNUSUAL
"    protected abstract DecayFunction getDecayFunction();

    private AbstractDistanceScoreFunction parseVariable(String fieldName, XContentParser parser, QueryShardContext context,
            MultiValueMode mode) throws IOException {
        //the field must exist, else we cannot read the value for the doc later
        MappedFieldType fieldType = context.fieldMapper(fieldName);
        if (fieldType == null) {
            throw new ParsingException(parser.getTokenLocation(), ""unknown field [{}]"", fieldName);
        }

        // dates and time and geo need special handling
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        public double evaluate(double value, double scale) {
            return Math.exp(scale * value);
        }

        @Override
        public Explanation explainFunction(String valueExpl, double value, double scale) {
            return Explanation.match(
                    (float) evaluate(value, scale),
                    ""exp(- "" + valueExpl + "" * "" + -1 * scale + "")"");
        }

";IL_INFINITE_RECURSIVE_LOOP
"        return Objects.hash(this.field, this.factor, this.missing, this.modifier);
    }

    @Override
    protected ScoreFunction doToFunction(QueryShardContext context) {
        MappedFieldType fieldType = context.getMapperService().fullName(field);
        IndexNumericFieldData fieldData = null;
        if (fieldType == null) {
            if(missing == null) {
                throw new ElasticsearchException(""Unable to find a field mapper for field ["" + field + ""]. No 'missing' value defined."");
            }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        public int hashCode() {
            return Objects.hash(filter, scoreFunction);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null || getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
"            // not need to square it here.
            return Math.exp(0.5 * Math.pow(value, 2.0) / scale);
        }

        @Override
        public Explanation explainFunction(String valueExpl, double value, double scale) {
            return Explanation.match(
                    (float) evaluate(value, scale),
                    ""exp(-0.5*pow("" + valueExpl + "",2.0)/"" + -1 * scale + "")"");
        }

";IL_INFINITE_RECURSIVE_LOOP
"        public double evaluate(double value, double scale) {
            return Math.max(0.0, (scale - value) / scale);
        }

        @Override
        public Explanation explainFunction(String valueExpl, double value, double scale) {
            return Explanation.match(
                    (float) evaluate(value, scale),
                    ""max(0.0, (("" + scale + "" - "" + valueExpl + "")/"" + scale + "")"");
        }

";IL_INFINITE_RECURSIVE_LOOP
"            this.analyzer = in.readOptionalString();
            this.useField = in.readOptionalString();
        }

        @Override
        public IntervalsSource getSource(QueryShardContext context, MappedFieldType fieldType) {
            NamedAnalyzer analyzer = fieldType.searchAnalyzer();
            if (this.analyzer != null) {
                analyzer = context.getMapperService().getIndexAnalyzers().get(this.analyzer);
            }
            IntervalsSource source;
";IL_INFINITE_RECURSIVE_LOOP
"            return Objects.hash(index, id, doc, Arrays.hashCode(fields), perFieldAnalyzer, routing,
                    version, versionType);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (!(o instanceof Item)) return false;
            Item other = (Item) o;
            return Objects.equals(index, other.index) &&
                    Objects.equals(id, other.id) &&
";EQ_UNUSUAL
"            buffer.append("")"");
            return buffer.toString();
        }

        @Override
        public boolean equals(Object obj) {
            if (sameClassAs(obj) == false)
                return false;
            ScriptQuery other = (ScriptQuery) obj;
            return Objects.equals(script, other.script);
        }
";EQ_UNUSUAL
"            SpanGapQueryBuilder result = new SpanGapQueryBuilder(fieldName, width);
            return result;
        }

        @Override
        public final boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null || getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
"            h = 31 * h + script.hashCode();
            return h;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null || getClass() != obj.getClass()) {
                return false;
            }
            ScriptLongValueSource that = (ScriptLongValueSource) obj;
            return Objects.equals(script, that.script);
";EQ_UNUSUAL
"        throw new UnsupportedOperationException(""usage of Streamable is to be replaced by Writeable"");
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null || obj.getClass() != RefreshStats.class) {
            return false;
        }
        RefreshStats rhs = (RefreshStats) obj;
        return total == rhs.total
                && totalTimeInMillis == rhs.totalTimeInMillis
";EQ_GETCLASS_AND_CLASS_CONSTANT
"            }
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (obj.getClass() != BulkByScrollTask.StatusOrException.class) {
                return false;
            }
";EQ_GETCLASS_AND_CLASS_CONSTANT
"        public String getRouting() {
            return fieldValue(RoutingFieldMapper.NAME);
        }

        private <T> T fieldValue(String fieldName) {
            DocumentField field = delegate.field(fieldName);
            return field == null ? null : field.getValue();
        }
    }
}
null
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return this;
    }

    @Override
    public ActionRequestValidationException validate() {
        ActionRequestValidationException e = super.validate();
        if (getSearchRequest().indices() == null || getSearchRequest().indices().length == 0) {
            e = addValidationError(""use _all if you really want to delete from all existing indexes"", e);
        }
        if (getSearchRequest() == null || getSearchRequest().source() == null) {
            e = addValidationError(""source is missing"", e);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        Map<String, Object> map = (Map<String, Object>) query;
        return BytesReference.bytes(builder.map(map));
    }

    private static boolean isQueryJson(BytesReference bytesReference) {
        try (XContentParser parser = QUERY_CONTENT_TYPE.createParser(NamedXContentRegistry.EMPTY,
            DeprecationHandler.THROW_UNSUPPORTED_OPERATION, bytesReference.streamInput())) {
            Map<String, Object> query = parser.map();
            return true;
        } catch (IOException e) {
            throw new AssertionError(""Could not parse JSON"", e);
";DLS_DEAD_LOCAL_STORE
"    public Weight createWeight(IndexSearcher searcher, org.apache.lucene.search.ScoreMode scoreMode, float boost) throws IOException {
        return query.createWeight(searcher, scoreMode, boost);
    }

    @Override
    public boolean equals(Object obj) {
        if (sameClassAs(obj) == false) {
            return false;
        }
        ESToParentBlockJoinQuery that = (ESToParentBlockJoinQuery) obj;
        return query.equals(that.query) && Objects.equals(path, that.path);
";EQ_UNUSUAL
"    }

    /** Returns true if a query on the given field might match parent documents
     *  or documents that are nested under a different path. */
    boolean mightMatchNonNestedDocs(String field, String nestedPath) {
        if (field.startsWith(""_"")) {
            // meta field. Every meta field behaves differently, eg. nested
            // documents have the same _uid as their parent, put their path in
            // the _type field but do not have _field_names. So we just ignore
            // meta fields and return true, which is always safe, it just means
            // we might add a nested filter when it is nor required.
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            return Objects.hash(lenient, analyzeWildcard, quoteFieldSuffix, autoGenerateSynonymsPhraseQuery,
                fuzzyPrefixLength, fuzzyMaxExpansions, fuzzyTranspositions);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null || getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
"     *
     * @throws InterruptedException if this thread was interrupted before of during waiting
     */
    @SuppressForbidden(reason = ""Object#wait for local checkpoint advancement"")
    private synchronized void waitForLocalCheckpointToAdvance() throws InterruptedException {
        this.wait();
    }

    /**
     * Represents the sequence number component of the primary context. This is the knowledge on the primary of the in-sync and initializing
     * shards and their local checkpoints.
";WA_NOT_IN_LOOP
"        }

    };

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        final RetentionLeases that = (RetentionLeases) o;
        return primaryTerm == that.primaryTerm &&
                version == that.version &&
";EQ_UNUSUAL
"                return Strings.toString(this);
            }


            @Override
            public boolean equals(Object o) {
                if (this == o) return true;
                if (o == null || getClass() != o.getClass()) return false;

                Status status = (Status) o;

";EQ_UNUSUAL
"                                                  long avgShardSizeInBytes, Map<Path,Integer> dataPathToShardCount) throws IOException {

        final Path dataPath;
        final Path statePath;

        if (indexSettings.hasCustomDataPath()) {
            dataPath = env.resolveCustomLocation(indexSettings, shardId);
            statePath = env.nodePaths()[0].resolve(shardId);
        } else {
            BigInteger totFreeSpace = BigInteger.ZERO;
            for (NodeEnvironment.NodePath nodePath : env.nodePaths()) {
";NP_UNWRITTEN_PUBLIC_OR_PROTECTED_FIELD
"    public String toString(String field) {
        return ""shard_splitting_query"";
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        ShardSplittingQuery that = (ShardSplittingQuery) o;

";EQ_UNUSUAL
"    public Similarity get() {
        return similarity;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        SimilarityProvider that = (SimilarityProvider) o;
        /**
         * We check <code>name</code> only because the <code>similarity</code> is
";EQ_UNUSUAL
"        digest.update(b);
    }

    @Override
    public void writeBytes(byte[] b, int offset, int length) throws IOException {
        out.writeBytes(b, offset, length);
        digest.update(b, offset, length);
    }

    @Override
    public void flush() throws IOException {
";NP_UNWRITTEN_FIELD
"            channel.force(false);
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Checkpoint that = (Checkpoint) o;

";EQ_UNUSUAL
"        private final long primaryTerm;
        private final long version;
        private final BytesReference source;
        private final String routing;

        private Index(final StreamInput in) throws IOException {
            final int format = in.readVInt(); // SERIALIZATION_FORMAT
            assert format >= FORMAT_NO_PARENT : ""format was: "" + format;
            id = in.readString();
            type = in.readString();
            source = in.readBytesReference();
";UC_USELESS_CONDITION
"    static int headerSizeInBytes(String translogUUID) {
        return headerSizeInBytes(CURRENT_VERSION, new BytesRef(translogUUID).length);
    }

    private static int headerSizeInBytes(int version, int uuidLength) {
        int size = CodecUtil.headerLength(TRANSLOG_CODEC);
        size += Integer.BYTES + uuidLength; // uuid
        if (version >= VERSION_PRIMARY_TERM) {
            size += Long.BYTES;    // primary term
            size += Integer.BYTES; // checksum
        }
";UPM_UNCALLED_PRIVATE_METHOD
"
public enum PreBuiltTokenizers {

    STANDARD(CachingStrategy.ONE) {
        @Override
        protected Tokenizer create(Version version) {
            return new StandardTokenizer();
        }
    }

    ;
";IL_INFINITE_RECURSIVE_LOOP
" */
public class AllCircuitBreakerStats implements Writeable, ToXContentFragment {

    private final CircuitBreakerStats[] allStats;

    public AllCircuitBreakerStats(CircuitBreakerStats[] allStats) {
        this.allStats = allStats;
    }

    public AllCircuitBreakerStats(StreamInput in) throws IOException {
        allStats = in.readArray(CircuitBreakerStats::new, CircuitBreakerStats[]::new);
";EI_EXPOSE_REP2
"        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Key key = (Key) o;
            if (!indexCache.equals(key.indexCache)) return false;
            if (!readerKey.equals(key.readerKey)) return false;
            return true;
        }

        @Override
        public int hashCode() {
";EQ_UNUSUAL
"        return shardId;
    }

    @Override
    public void readFrom(StreamInput in) throws IOException {
        failureReason = in.readOptionalString();
        int numResponses = in.readInt();
        shardResponses = new HashMap<>();
        for (int i = 0; i < numResponses; i++) {
            ShardRouting shardRouting = new ShardRouting(in);
            SyncedFlushService.ShardSyncedFlushResponse response = SyncedFlushService.ShardSyncedFlushResponse.readSyncedFlushResponse(in);
";DLS_DEAD_LOCAL_STORE
"            this.bytesUsed = bytesUsed;
            this.shard = shard;
        }

        @Override
        public int compareTo(ShardAndBytesUsed other) {
            // Sort larger shards first:
            return Long.compare(other.bytesUsed, bytesUsed);
        }
    }

";EQ_COMPARETO_USE_OBJECT_EQUALS
"    private static final Map<String, MetadataFieldMapper.TypeParser> builtInMetadataMappers = initBuiltInMetadataMappers();

    private static Map<String, MetadataFieldMapper.TypeParser> initBuiltInMetadataMappers() {
        Map<String, MetadataFieldMapper.TypeParser> builtInMetadataMappers;
        // Use a LinkedHashMap for metadataMappers because iteration order matters
        builtInMetadataMappers = new LinkedHashMap<>();
        // _ignored first so that we always load it, even if only _id is requested
        builtInMetadataMappers.put(IgnoredFieldMapper.NAME, new IgnoredFieldMapper.TypeParser());
        // ID second so it will be the first (if no ignored fields) stored field to load
        // (so will benefit from ""fields: []"" early termination
        builtInMetadataMappers.put(IdFieldMapper.NAME, new IdFieldMapper.TypeParser());
";UC_USELESS_OBJECT
"        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Key key = (Key) o;
            if (Objects.equals(readerCacheKey, key.readerCacheKey) == false) return false;
            if (!entity.getCacheIdentity().equals(key.entity.getCacheIdentity())) return false;
            if (!value.equals(key.value)) return false;
            return true;
        }

";EQ_UNUSUAL
"            }
            return sb.toString();
        }

        @Override
        public int compareTo(PendingDelete o) {
            return Integer.compare(shardId, o.shardId);
        }
    }

    /**
";EQ_COMPARETO_USE_OBJECT_EQUALS
"        phase1ExistingFileSizes = in.readList(StreamInput::readVLong);
        phase1TotalSize = in.readVLong();
        phase1ExistingTotalSize = in.readVLong();
        phase1Time = in.readVLong();
        phase1ThrottlingWaitTime = in.readVLong();
        startTime = in.readVLong();
        phase2Operations = in.readVInt();
        phase2Time = in.readVLong();
    }

    @Override
";WMI_WRONG_MAP_ITERATOR
"            return readBoolean(processorType, processorTag, propertyName, value).booleanValue();
        }
    }

    private static Boolean readBoolean(String processorType, String processorTag, String propertyName, Object value) {
        if (value == null) {
            return null;
        }
        if (value instanceof Boolean) {
            return (Boolean) value;
        }
";NP_BOOLEAN_RETURN_NULL
"        this.ingestService = ingestService;
    }

    @Override
    public IngestDocument execute(IngestDocument ingestDocument) throws Exception {
        Pipeline pipeline = ingestService.getPipeline(pipelineName);
        if (pipeline == null) {
            throw new IllegalStateException(""Pipeline processor configured for non-existent pipeline ["" + pipelineName + ']');
        }
        return ingestDocument.executePipeline(pipeline);
    }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            this.value = value;
        }

        @Override
        public Object copyAndResolve(Map<String, Object> model) {
            return value;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
";EI_EXPOSE_REP
"        final long totalReadOperations;
        final long totalWriteOperations;
        final long totalReadKilobytes;
        final long totalWriteKilobytes;

        public IoStats(final DeviceStats[] devicesStats) {
            this.devicesStats = devicesStats;
            long totalOperations = 0;
            long totalReadOperations = 0;
            long totalWriteOperations = 0;
            long totalReadKilobytes = 0;
";EI_EXPOSE_REP2
"
    public static class GarbageCollectors implements Writeable, Iterable<GarbageCollector> {

        private final GarbageCollector[] collectors;

        public GarbageCollectors(GarbageCollector[] collectors) {
            this.collectors = collectors;
        }

        public GarbageCollectors(StreamInput in) throws IOException {
            collectors = in.readArray(GarbageCollector::new, GarbageCollector[]::new);
";EI_EXPOSE_REP2
"    public static class Cpu implements Writeable, ToXContentFragment {

        private final short percent;
        private final double[] loadAverage;

        public Cpu(short systemCpuPercent, double[] systemLoadAverage) {
            this.percent = systemCpuPercent;
            this.loadAverage = systemLoadAverage;
        }

        public Cpu(StreamInput in) throws IOException {
";EI_EXPOSE_REP2
"
    /**
     * Returns the CPU time (in milliseconds) used by the process on which the Java virtual machine is running, or -1 if not supported.
     */
    public long getProcessCpuTotalTime() {
        if (getProcessCpuTime != null) {
            try {
                long time = (long) getProcessCpuTime.invoke(osMxBean);
                if (time >= 0) {
                    return (time / 1_000_000L);
                }
";REC_CATCH_EXCEPTION
"    /**
     * Finish preparing settings by replacing forced settings and any defaults that need to be added.
     */
    private static void finalizeSettings(Settings.Builder output, Supplier<String> defaultNodeName) {
        // allow to force set properties based on configuration of the settings provided
        List<String> forcedSettings = new ArrayList<>();
        for (String setting : output.keys()) {
            if (setting.startsWith(""force."")) {
                forcedSettings.add(setting);
            }
        }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            if (value.length() > 0
                && (Character.isWhitespace(value.charAt(0)) || Character.isWhitespace(value.charAt(value.length() - 1)))) {
                throw new IllegalArgumentException(key + "" cannot have leading or trailing whitespace "" +
                    ""["" + value + ""]"");
            }
            if (value.length() > 0 && ""node.attr.server_name"".equals(key)) {
                try {
                    new SNIHostName(value);
                } catch (IllegalArgumentException e) {
                    throw new IllegalArgumentException(""invalid node.attr.server_name ["" + value + ""]"", e );
                }
";EQ_UNUSUAL
"        return PERSISTENT_TASKS_PARSER.apply(parser, null).build();
    }

    @SuppressWarnings(""unchecked"")
    public static <Params extends PersistentTaskParams> PersistentTask<Params> getTaskWithId(ClusterState clusterState, String taskId) {
        PersistentTasksCustomMetaData tasks = clusterState.metaData().custom(PersistentTasksCustomMetaData.TYPE);
        if (tasks != null) {
            return (PersistentTask<Params>) tasks.getTask(taskId);
        }
        return null;
    }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"
    /**
     * Finds the least loaded node that satisfies the selector criteria
     */
    protected DiscoveryNode selectLeastLoadedNode(ClusterState clusterState, Predicate<DiscoveryNode> selector) {
        long minLoad = Long.MAX_VALUE;
        DiscoveryNode minLoadedNode = null;
        PersistentTasksCustomMetaData persistentTasks = clusterState.getMetaData().custom(PersistentTasksCustomMetaData.TYPE);
        for (DiscoveryNode node : clusterState.getNodes()) {
            if (selector.test(node)) {
                if (persistentTasks == null) {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        public boolean isFragment() {
            return false;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Status status = (Status) o;
            return state == status.state;
        }
";EQ_UNUSUAL
"            }
            this.urls = Objects.requireNonNull(urls);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            Bundle bundle = (Bundle) o;
            return Objects.equals(plugin, bundle.plugin);
        }
";EQ_UNUSUAL
"        return ""cluster_reroute_action"";
    }

    @Override
    public RestChannelConsumer prepareRequest(final RestRequest request, final NodeClient client) throws IOException {
        ClusterRerouteRequest clusterRerouteRequest = createRequest(request);
        settingsFilter.addFilterSettingParams(request);
        if (clusterRerouteRequest.explain()) {
            request.params().put(""explain"", Boolean.TRUE.toString());
        }
        // by default, return everything but metadata
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return ""put_stored_script_action"";
    }

    @Override
    public RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {
        String id = request.param(""id"");
        String context = request.param(""context"");
        BytesReference content = request.requiredContent();
        XContentType xContentType = request.getXContentType();
        StoredScriptSource source = StoredScriptSource.parse(content, xContentType);

";DLS_DEAD_LOCAL_STORE
"        return ""nodes_reload_action"";
    }

    @Override
    public RestChannelConsumer prepareRequest(RestRequest request, NodeClient client) throws IOException {
        final String[] nodesIds = Strings.splitStringByCommaToArray(request.param(""nodeId""));
        final NodesReloadSecureSettingsRequestBuilder nodesRequestBuilder = client.admin()
                .cluster()
                .prepareReloadSecureSettings()
                .setTimeout(request.param(""timeout""))
                .setNodesIds(nodesIds);
";DLS_DEAD_LOCAL_STORE
"        return ""cat_fielddata_action"";
    }

    @Override
    protected RestChannelConsumer doCatRequest(final RestRequest request, final NodeClient client) {
        final NodesStatsRequest nodesStatsRequest = new NodesStatsRequest(""data:true"");
        nodesStatsRequest.clear();
        nodesStatsRequest.indices(true);
        String[] fields = request.paramAsStringArray(""fields"", null);
        nodesStatsRequest.indices().fieldDataFields(fields == null ? new String[] {""*""} : fields);

";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"                .endHeaders();
        return table;
    }

    private Table buildTable(RestRequest request, ClusterStateResponse state) {
        Table table = getTableWithHeader(request);
        DiscoveryNodes nodes = state.getState().nodes();

        table.startRow();
        DiscoveryNode master = nodes.get(nodes.getMasterNodeId());
        if (master == null) {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    }

    private static final DateFormatter FORMATTER = DateFormatter.forPattern(""HH:mm:ss"").withZone(ZoneOffset.UTC);

    private void buildRow(Table table, boolean fullId, boolean detailed, DiscoveryNodes discoveryNodes, TaskInfo taskInfo) {
        table.startRow();
        String nodeId = taskInfo.getTaskId().getNodeId();
        DiscoveryNode node = discoveryNodes.get(nodeId);

        table.addCell(taskInfo.getId());
        table.addCell(taskInfo.getAction());
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        table.endHeaders();
        return table;
    }

    private Table buildTable(RestRequest req, ClusterStateResponse state, NodesInfoResponse nodesInfo, NodesStatsResponse nodesStats) {
        final String[] threadPools = req.paramAsStringArray(""thread_pool_patterns"", new String[] { ""*"" });
        final DiscoveryNodes nodes = state.getState().nodes();
        final Table table = getTableWithHeader(req);

        // collect all thread pool names that we see across the nodes
        final Set<String> candidates = new HashSet<>();
";BX_UNBOXING_IMMEDIATELY_REBOXED
"
        return new BytesRestResponse(RestStatus.OK, builder);
    }

    public static QueryBuilder urlParamsToQueryBuilder(RestRequest request) {
        String queryString = request.param(""q"");
        if (queryString == null) {
            return null;
        }
        QueryStringQueryBuilder queryBuilder = QueryBuilders.queryStringQuery(queryString);
        queryBuilder.defaultField(request.param(""df""));
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"     * @throws IllegalArgumentException if {@link #TOTAL_HITS_AS_INT_PARAM}
     * is used in conjunction with a lower bound value (other than {@link SearchContext#DEFAULT_TRACK_TOTAL_HITS_UP_TO})
     * for the track_total_hits option.
     */
    public static void checkRestTotalHits(RestRequest restRequest, SearchRequest searchRequest) {
        boolean totalHitsAsInt = restRequest.paramAsBoolean(TOTAL_HITS_AS_INT_PARAM, false);
        if (totalHitsAsInt == false) {
            return;
        }
        if (searchRequest.source() == null) {
            searchRequest.source(new SearchSourceBuilder());
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return new String(buf, 0, pos, charset);
    }

    @SuppressWarnings(""fallthrough"")
    private static boolean decodingNeeded(String s, int size) {
        boolean decodingNeeded = false;
        for (int i = 0; i < size; i++) {
            final char c = s.charAt(i);
            switch (c) {
                case '%':
                    i++;  // We can skip at least one char, e.g. `%%'.
";SF_SWITCH_NO_DEFAULT
"    public ZonedDateTime getZonedDateTime() {
        return dt;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        JodaCompatibleZonedDateTime that = (JodaCompatibleZonedDateTime) o;
        return Objects.equals(dt, that.dt);
    }
";EQ_UNUSUAL
"
    /** A class that is an instance of a script. */
    public final Class<?> instanceClazz;

    /** Construct a context with the related instance and compiled classes. */
    public ScriptContext(String name, Class<FactoryType> factoryClazz) {
        this.name = name;
        this.factoryClazz = factoryClazz;
        Method newInstanceMethod = findMethod(""FactoryType"", factoryClazz, ""newInstance"");
        Method newFactoryMethod = findMethod(""FactoryType"", factoryClazz, ""newFactory"");
        if (newFactoryMethod != null) {
";NP_LOAD_OF_KNOWN_NULL_VALUE
"    StoredScriptSource getStoredScript(String id) {
        return scripts.get(id);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        ScriptMetaData that = (ScriptMetaData)o;

";EQ_UNUSUAL
"            this.context = context;
            this.options = options;
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) return true;
            if (o == null || getClass() != o.getClass()) return false;
            CacheKey cacheKey = (CacheKey) o;
            return Objects.equals(lang, cacheKey.lang) &&
                Objects.equals(idOrCode, cacheKey.idOrCode) &&
";EQ_UNUSUAL
"    public Map<String, String> getOptions() {
        return options;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        StoredScriptSource that = (StoredScriptSource)o;

";EQ_UNUSUAL
"    /**
     * Constructs a new aggregation builder.
     *
     * @param name  The aggregation name
     */
    protected AggregationBuilder(String name) {
        if (name == null) {
            throw new IllegalArgumentException(""[name] must not be null: ["" + name + ""]"");
        }
        this.name = name;
    }
";NP_LOAD_OF_KNOWN_NULL_VALUE
"        public int hashCode() {
            return Objects.hash(key, filter);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
"        return timeZone;
    }

    @Override
    protected CompositeValuesSourceConfig innerBuild(SearchContext context, ValuesSourceConfig<?> config) throws IOException {
        Rounding rounding = dateHistogramInterval.createRounding(timeZone());
        ValuesSource orig = config.toValuesSource(context.getQueryShardContext());
        if (orig == null) {
            orig = ValuesSource.Numeric.EMPTY;
        }
        if (orig instanceof ValuesSource.Numeric) {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        return this;
    }

    @Override
    protected CompositeValuesSourceConfig innerBuild(SearchContext context, ValuesSourceConfig<?> config) throws IOException {
        ValuesSource orig = config.toValuesSource(context.getQueryShardContext());
        if (orig == null) {
            orig = ValuesSource.Numeric.EMPTY;
        }
        if (orig instanceof ValuesSource.Numeric) {
            ValuesSource.Numeric numeric = (ValuesSource.Numeric) orig;
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            this.it = buckets.iterator();
        }

        @Override
        public int compareTo(BucketIterator other) {
            return current.compareKey(other.current);
        }

        InternalBucket next() {
            return current = it.hasNext() ? it.next() : null;
        }
";EQ_COMPARETO_USE_OBJECT_EQUALS
"        return TYPE;
    }

    @Override
    protected CompositeValuesSourceConfig innerBuild(SearchContext context, ValuesSourceConfig<?> config) throws IOException {
        ValuesSource vs = config.toValuesSource(context.getQueryShardContext());
        if (vs == null) {
            // The field is unmapped so we use a value source that can parse any type of values.
            // This is needed because the after values are parsed even when there are no values to process.
            vs = ValuesSource.Bytes.WithOrdinals.EMPTY;
        }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        public int hashCode() {
            return Objects.hash(key, filter);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
"        public int hashCode() {
            return Objects.hash(rounding, Arrays.hashCode(innerIntervals), dateTimeUnit);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (obj.getClass() != getClass()) {
                return false;
";EQ_UNUSUAL
"                                              RoundingInfo[] roundingInfos,
                                              SearchContext context,
                                              AggregatorFactory parent,
                                              AggregatorFactories.Builder subFactoriesBuilder,
                                              Map<String, Object> metaData) throws IOException {
        super(name, config, context, parent, subFactoriesBuilder, metaData);
        this.numBuckets = numBuckets;
        this.roundingInfos = roundingInfos;
    }

    @Override
";EI_EXPOSE_REP2
"    public int hashCode() {
        return Objects.hash(super.hashCode(), order, keyed, minDocCount, dateHistogramInterval, minDocCount, extendedBounds);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        if (super.equals(obj) == false) return false;
        DateHistogramAggregationBuilder other = (DateHistogramAggregationBuilder) obj;
        return Objects.equals(order, other.order)
";EQ_UNUSUAL
"        }
        return builder;
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }
        if (other == null || getClass() != other.getClass()) {
            return false;
";EQ_UNUSUAL
"            aggregations = new InternalAggregations(in);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null || obj.getClass() != InternalAutoDateHistogram.Bucket.class) {
                return false;
            }
            InternalAutoDateHistogram.Bucket that = (InternalAutoDateHistogram.Bucket) obj;
            // No need to take the keyed and format parameters into account,
            // they are already stored and tested on the InternalDateHistogram object
";EQ_GETCLASS_AND_CLASS_CONSTANT
"            aggregations = new InternalAggregations(in);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null || obj.getClass() != InternalDateHistogram.Bucket.class) {
                return false;
            }
            InternalDateHistogram.Bucket that = (InternalDateHistogram.Bucket) obj;
            // No need to take the keyed and format parameters into account,
            // they are already stored and tested on the InternalDateHistogram object
";EQ_GETCLASS_AND_CLASS_CONSTANT
"            aggregations = new InternalAggregations(in);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null || obj.getClass() != Bucket.class) {
                return false;
            }
            Bucket that = (Bucket) obj;
            // No need to take the keyed and format parameters into account,
            // they are already stored and tested on the InternalHistogram object
";EQ_GETCLASS_AND_CLASS_CONSTANT
"    private final boolean keyed;

    public AbstractRangeAggregatorFactory(String name, ValuesSourceConfig<Numeric> config, R[] ranges, boolean keyed,
            InternalRange.Factory<?, ?> rangeFactory, SearchContext context, AggregatorFactory parent,
            AggregatorFactories.Builder subFactoriesBuilder, Map<String, Object> metaData) throws IOException {
        super(name, config, context, parent, subFactoriesBuilder, metaData);
        this.ranges = ranges;
        this.keyed = keyed;
        this.rangeFactory = rangeFactory;
    }

";EI_EXPOSE_REP2
"    protected DateRangeAggregatorFactory innerBuild(SearchContext context, ValuesSourceConfig<Numeric> config,
            AggregatorFactory parent, Builder subFactoriesBuilder) throws IOException {
        // We need to call processRanges here so they are parsed and we know whether `now` has been used before we make
        // the decision of whether to cache the request
        RangeAggregator.Range[] ranges = processRanges(range -> {
            DocValueFormat parser = config.format();
            assert parser != null;
            double from = range.getFrom();
            double to = range.getTo();
            String fromAsString = range.getFromAsString();
            String toAsString = range.getToAsString();
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        // should not happen since we only parse geo points when we encounter a string, an object or an array
        throw new IllegalArgumentException(""Unexpected token ["" + token + ""] while parsing geo point"");
    }

    private static Range parseRange(XContentParser parser) throws IOException {
        String fromAsStr = null;
        String toAsStr = null;
        double from = 0.0;
        double to = Double.POSITIVE_INFINITY;
        String key = null;
        String currentFieldName = null;
";NP_NULL_PARAM_DEREF
"    private final boolean keyed;

    public GeoDistanceRangeAggregatorFactory(String name, ValuesSourceConfig<ValuesSource.GeoPoint> config, GeoPoint origin,
            Range[] ranges, DistanceUnit unit, GeoDistance distanceType, boolean keyed, SearchContext context,
            AggregatorFactory parent, AggregatorFactories.Builder subFactoriesBuilder, Map<String, Object> metaData) throws IOException {
        super(name, config, context, parent, subFactoriesBuilder, metaData);
        this.origin = origin;
        this.ranges = ranges;
        this.unit = unit;
        this.distanceType = distanceType;
        this.keyed = keyed;
";EI_EXPOSE_REP2
"            Bucket bucket = (Bucket) o;

            if (docCount != bucket.docCount) return false;
            // keyed and format are ignored since they are already tested on the InternalBinaryRange object
            return Objects.equals(key, bucket.key) &&
                Objects.equals(from, bucket.from) &&
                Objects.equals(to, bucket.to) &&
                Objects.equals(aggregations, bucket.aggregations);
        }

        @Override
";EQ_UNUSUAL
"        public int hashCode() {
            return Objects.hash(key, from, fromAsStr, to, toAsStr);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
"        return Objects.hash(script);
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
";EQ_DOESNT_OVERRIDE_EQUALS
"        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null || getClass() != obj.getClass()) return false;
            if (super.equals(obj) == false) return false;

            return super.equals(obj) && Objects.equals(termBytes, ((SignificantStringTerms.Bucket) obj).termBytes);
        }

        @Override
        public int hashCode() {
            return Objects.hash(super.hashCode(), termBytes);
";EQ_UNUSUAL
"            return false;
        } if (getClass() != obj.getClass()) {
            return false;
        }
        IncludeExclude other = (IncludeExclude) obj;
        return Objects.equals(include == null ? null : include.getOriginalString(),
                other.include == null ? null : other.include.getOriginalString())
                && Objects.equals(exclude == null ? null : exclude.getOriginalString(),
                        other.exclude == null ? null : other.exclude.getOriginalString())
                && Objects.equals(includeValues, other.includeValues) && Objects.equals(excludeValues, other.excludeValues)
                && Objects.equals(incZeroBasedPartition, other.incZeroBasedPartition)
";EQ_UNUSUAL
"        }
        return bucketMap.get(term);
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        if (super.equals(obj) == false) return false;
        InternalMappedRareTerms<?,?> that = (InternalMappedRareTerms<?,?>) obj;
        return Objects.equals(buckets, that.buckets)
";EQ_UNUSUAL
"            return builder.field(CommonFields.KEY.getPreferredName(), getKeyAsString());
        }

        @Override
        public boolean equals(Object obj) {
            return super.equals(obj) && Objects.equals(termBytes, ((Bucket) obj).termBytes);
        }

        @Override
        public int hashCode() {
            return Objects.hash(super.hashCode(), termBytes);
";EQ_UNUSUAL
"            return builder.field(CommonFields.KEY.getPreferredName(), getKeyAsString());
        }

        @Override
        public boolean equals(Object obj) {
            return super.equals(obj) && Objects.equals(termBytes, ((Bucket) obj).termBytes);
        }

        @Override
        public int hashCode() {
            return Objects.hash(super.hashCode(), termBytes);
";EQ_UNUSUAL
"        public int hashCode() {
            return Objects.hash(requiredSize, shardSize, minDocCount, shardMinDocCount);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
"        if (super.equals(obj) == false) return false;

        AbstractInternalHDRPercentiles that = (AbstractInternalHDRPercentiles) obj;
        return keyed == that.keyed
                && Arrays.equals(keys, that.keys)
                && Objects.equals(state, that.state);
    }

    @Override
    public int hashCode() {
        // we cannot use state.hashCode at the moment because of:
";EQ_UNUSUAL
"
        private final double[] values;
        private final TDigestState state;
        private int i;

        public Iter(double[] values, TDigestState state) {
            this.values = values;
            this.state = state;
            i = 0;
        }

";EI_EXPOSE_REP2
"
        private final double[] percents;
        private final TDigestState state;
        private int i;

        public Iter(double[] percents, TDigestState state) {
            this.percents = percents;
            this.state = state;
            i = 0;
        }

";EI_EXPOSE_REP2
"        if (super.equals(obj) == false) return false;

        InternalTopHits other = (InternalTopHits) obj;
        if (from != other.from) return false;
        if (size != other.size) return false;
        if (topDocs.topDocs.totalHits.value != other.topDocs.topDocs.totalHits.value) return false;
        if (topDocs.topDocs.totalHits.relation != other.topDocs.topDocs.totalHits.relation) return false;
        if (topDocs.topDocs.scoreDocs.length != other.topDocs.topDocs.scoreDocs.length) return false;
        for (int d = 0; d < topDocs.topDocs.scoreDocs.length; d++) {
            ScoreDoc thisDoc = topDocs.topDocs.scoreDocs[d];
            ScoreDoc otherDoc = other.topDocs.topDocs.scoreDocs[d];
";EQ_UNUSUAL
"
    /**
     * Get the values to compute percentiles from.
     */
    public double[] values() {
        return values;
    }

    /**
     * Set whether the XContent response should be keyed
     */
";EI_EXPOSE_REP
"        return builder;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        if (super.equals(obj) == false) return false;

        PercentilesAggregationBuilder other = (PercentilesAggregationBuilder) obj;
        if (Objects.equals(method, other.method) == false) {
";EQ_DOESNT_OVERRIDE_EQUALS
"        builder.endObject();
        return builder;
    }

    public static ScriptedMetricAggregationBuilder parse(String aggregationName, XContentParser parser) throws IOException {
        Script initScript = null;
        Script mapScript = null;
        Script combineScript = null;
        Script reduceScript = null;
        Map<String, Object> params = null;
        XContentParser.Token token;
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        }
        return state;
    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null || obj instanceof TDigestState == false) {
            return false;
        }
        TDigestState that = (TDigestState) obj;
        if (compression != that.compression) {
";EQ_UNUSUAL
"     *            The name of the field
     * @param order
     *            The sort ordering
     */
    public TopHitsAggregationBuilder sort(String name, SortOrder order) {
        if (name == null) {
            throw new IllegalArgumentException(""sort [name] must not be null: ["" + name + ""]"");
        }
        if (order == null) {
            throw new IllegalArgumentException(""sort [order] must not be null: ["" + name + ""]"");
        }
";NP_LOAD_OF_KNOWN_NULL_VALUE
"            return sortValues.isEmpty();
        }

        @Override
        public int compareTo(ComparableBucket that) {
            int compareResult = 0;
            for (FieldSortBuilder sort : sorts) {
                Comparable<Object> thisValue = this.sortValues.get(sort);
                Comparable<Object> thatValue = that.sortValues.get(sort);
                if (thisValue == null && thatValue == null) {
                    continue;
";RV_NEGATING_RESULT_OF_COMPARETO
"    private double value;
    private String[] keys;

    public InternalBucketMetricValue(String name, String[] keys, double value, DocValueFormat formatter,
            List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) {
        super(name, pipelineAggregators, metaData);
        this.keys = keys;
        this.value = value;
        this.format = formatter;
    }

";EI_EXPOSE_REP2
"
        private final double[] percents;
        private final double[] percentiles;
        private int i;

        public Iter(double[] percents, double[] percentiles) {
            this.percents = percents;
            this.percentiles = percentiles;
            i = 0;
        }

";EI_EXPOSE_REP2
"
    /**
     * Set the percentages to calculate percentiles for in this aggregation
     */
    public PercentilesBucketPipelineAggregationBuilder setPercents(double[] percents) {
        if (percents == null) {
            throw new IllegalArgumentException(""[percents] must not be null: ["" + name + ""]"");
        }
        for (Double p : percents) {
            if (p == null || p < 0.0 || p > 100.0) {
                throw new IllegalArgumentException(PERCENTS_FIELD.getPreferredName()
";EI_EXPOSE_REP2
"    public String name() {
        return name;
    }

    public String[] bucketsPaths() {
        return bucketsPaths;
    }

    public Map<String, Object> metaData() {
        return metaData;
    }
";EI_EXPOSE_REP
"     * Constructs a new pipeline aggregator factory.
     *
     * @param name
     *            The aggregation name
     */
    protected PipelineAggregationBuilder(String name, String[] bucketsPaths) {
        if (name == null) {
            throw new IllegalArgumentException(""[name] must not be null: ["" + name + ""]"");
        }
        if (bucketsPaths == null) {
            throw new IllegalArgumentException(""[bucketsPaths] must not be null: ["" + name + ""]"");
";NP_LOAD_OF_KNOWN_NULL_VALUE
"     * Registers all the created aggregators (top level aggregators) for the search execution context.
     *
     * @param aggregators The top level aggregators of the search execution.
     */
    public void aggregators(Aggregator[] aggregators) {
        this.aggregators = aggregators;
    }

    /**
     * Returns a consumer for multi bucket aggregation that checks the total number of buckets
     * created in the response
";EI_EXPOSE_REP2
"    }

    @Override
    public Aggregator createInternal(Aggregator parent, boolean collectsFromSingleBucket,
            List<PipelineAggregator> pipelineAggregators, Map<String, Object> metaData) throws IOException {
        VS vs = config.toValuesSource(context.getQueryShardContext(), this::resolveMissingAny);
        if (vs == null) {
            return createUnmapped(parent, pipelineAggregators, metaData);
        }
        return doCreateInternal(vs, parent, collectsFromSingleBucket, pipelineAggregators, metaData);
    }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            String field, Script script,
            Object missing,
            ZoneId timeZone,
            String format) {

        if (field == null) {
            if (script == null) {
                ValuesSourceConfig<VS> config = new ValuesSourceConfig<>(ValuesSourceType.ANY);
                config.format(resolveFormat(null, valueType, timeZone));
                return config;
            }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        public int hashCode() {
            return Objects.hash(fieldName, script, ignoreFailure);
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == null) {
                return false;
            }
            if (getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
"        @Override
        public void writeTo(StreamOutput out) {
        }

        @Override
        public String format(BytesRef value) {
            byte[] bytes = Arrays.copyOfRange(value.bytes, value.offset, value.offset + value.length);
            InetAddress inet = InetAddressPoint.decode(bytes);
            return NetworkAddress.format(inet);
        }

";UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS
"        assert assertNoSearchTarget(hits);
        this.hits = hits;
    }

    private boolean assertNoSearchTarget(SearchHits hits) {
        for (SearchHit hit : hits.getHits()) {
            assert hit.getShard() == null : ""expected null but got: "" + hit.getShard();
        }
        return true;
    }

";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"                parser.getTokenLocation());
        }
    }

    public static StoredFieldsContext fromRestRequest(String name, RestRequest request) {
        String sField = request.param(name);
        if (sField != null) {
            String[] sFields = Strings.splitStringByCommaToArray(sField);
            return fromList(Arrays.asList(sFields));
        }
        return null;
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    public boolean fetchSource() {
        return this.fetchSource;
    }

    public String[] includes() {
        return this.includes;
    }

    public String[] excludes() {
        return this.excludes;
    }
";EI_EXPOSE_REP
"
public final class FetchSourceSubPhase implements FetchSubPhase {

    @Override
    public void hitExecute(SearchContext context, HitContext hitContext) {
        if (context.sourceRequested() == false) {
            return;
        }
        final boolean nestedHit = hitContext.hit().getNestedIdentity() != null;
        SourceLookup source = context.lookup().source();
        FetchSourceContext fetchSourceContext = context.fetchSourceContext();
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"     * defines what constitutes a boundary for highlighting. Its a single string with
     * each boundary character defined in it. It defaults to .,!? \t\n
     */
    @SuppressWarnings(""unchecked"")
    public HB boundaryChars(char[] boundaryChars) {
        this.boundaryChars = boundaryChars;
        return (HB) this;
    }

    /**
     * @return the value set by {@link #boundaryChars(char[])}
";EI_EXPOSE_REP2
"    private Text[] fragments;

    HighlightField() {
    }

    public HighlightField(String name, Text[] fragments) {
        this.name = Objects.requireNonNull(name, ""missing highlight field name"");
        this.fragments = fragments;
    }

    /**
";EI_EXPOSE_REP2
"            .collect(Collectors.toList());
        return fieldValues;
    }

    protected BreakIterator getBreakIterator(SearchContextHighlight.Field field) {
        final SearchContextHighlight.FieldOptions fieldOptions = field.fieldOptions();
        final Locale locale =
            fieldOptions.boundaryScannerLocale() != null ? fieldOptions.boundaryScannerLocale() :
                Locale.ROOT;
        final HighlightBuilder.BoundaryScannerType type =
            fieldOptions.boundaryScannerType()  != null ? fieldOptions.boundaryScannerType() :
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    /**
     * Returns the aliases patters that are used to compose the {@link QueryBuilder}
     * returned from {@link #getQueryBuilder()}
     */
    public String[] getAliases() {
        return aliases;
    }

    /**
     * Returns the alias filter {@link QueryBuilder} or <code>null</code> if there is no such filter
     */
";EI_EXPOSE_REP
"    public SearchContext searchAfter(FieldDoc searchAfter) {
        return in.searchAfter(searchAfter);
    }

    @Override
    public FieldDoc searchAfter() {
        return in.searchAfter();
    }

    @Override
    public SearchContext parsedPostFilter(ParsedQuery postFilter) {
";IL_INFINITE_RECURSIVE_LOOP
"        return scroll;
    }

    @Override
    public String[] indexRoutings() {
        return indexRoutings;
    }

    @Override
    public String preference() {
        return preference;
";EI_EXPOSE_REP
"                    }
                    return false;
                }

                @Override
                public double doubleValue() throws IOException {
                    return this.value;
                }
            };
        }
    }
";UMAC_UNCALLABLE_METHOD_OF_ANONYMOUS_CLASS
"        public static NestedIdentity fromXContent(XContentParser parser) {
            return PARSER.apply(parser, null);
        }

        @Override
        public boolean equals(Object obj) {
            if (this == obj) {
                return true;
            }
            if (obj == null || getClass() != obj.getClass()) {
                return false;
";EQ_UNUSUAL
"    public boolean equals(Object obj) {
        if (obj == null || getClass() != obj.getClass()) {
            return false;
        }
        SearchHits other = (SearchHits) obj;
        return Objects.equals(totalHits, other.totalHits)
                && Objects.equals(maxScore, other.maxScore)
                && Arrays.equals(hits, other.hits)
                && Arrays.equals(sortFields, other.sortFields)
                && Objects.equals(collapseField, other.collapseField)
                && Arrays.equals(collapseValues, other.collapseValues);
";EQ_UNUSUAL
"    public SearchParseException(SearchContext context, String msg, @Nullable XContentLocation location) {
        this(context, msg, location, null);
    }

    public SearchParseException(SearchContext context, String msg, @Nullable XContentLocation location, Throwable cause) {
        super(context, msg, cause);
        int lineNumber = UNKNOWN_POSITION;
        int columnNumber = UNKNOWN_POSITION;
        if (location != null) {
            if (location != null) {
                lineNumber = location.lineNumber;
";RpC_REPEATED_CONDITIONAL_TEST
"
    /**
     * Returns the raw version of the values that sorting was performed against
     */
    public Object[] getRawSortValues() {
        return rawSortValues;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
";EI_EXPOSE_REP
"        SliceBuilder builder = PARSER.parse(parser, new SliceBuilder(), null);
        return builder;
    }

    @Override
    public boolean equals(Object other) {
        if (!(other instanceof SliceBuilder)) {
            return false;
        }

        SliceBuilder o = (SliceBuilder) other;
";EQ_UNUSUAL
"    public int getMax() {
        return max;
    }

    @Override
    public boolean equals(Object o) {
        if (sameClassAs(o) == false) {
            return false;
        }
        SliceQuery that = (SliceQuery) o;
        return field.equals(that.field) && id == that.id && max == that.max;
";EQ_UNUSUAL
"            }
        }
    }

    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }

        if (other == null || getClass() != other.getClass()) {
";EQ_UNUSUAL
"
    /**
     * Read from a stream.
     */
    @SuppressWarnings(""unchecked"")
    public GeoDistanceSortBuilder(StreamInput in) throws IOException {
        fieldName = in.readString();
        points.addAll((List<GeoPoint>) in.readGenericValue());
        geoDistance = GeoDistance.readFromStream(in);
        unit = DistanceUnit.readFromStream(in);
        order = SortOrder.readFromStream(in);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            return SORT_SCORE_REVERSE;
        }
    }

    @Override
    public boolean equals(Object object) {
        if (this == object) {
            return true;
        }
        if (object == null || getClass() != object.getClass()) {
            return false;
";EQ_UNUSUAL
"    }

    /**
     * Read from a stream.
     */
    public ScriptSortBuilder(StreamInput in) throws IOException {
        script = new Script(in);
        type = ScriptSortType.readFromStream(in);
        order = SortOrder.readFromStream(in);
        sortMode = in.readOptionalWriteable(SortMode::readFromStream);
        if (in.getVersion().before(Version.V_8_0_0)) {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"            this.current = optionsIterator.next();
            assert this.current.getDoc().shardIndex != -1 : ""shardIndex is not set"";
        }

        boolean advanceToNextOption() {
            if (optionsIterator.hasNext()) {
                current = optionsIterator.next();
                return true;
            } else {
                return false;
            }
";NP_UNWRITTEN_FIELD
"        return new CompletionSuggestionBuilder(field, builder);
    }

    @Override
    public SuggestionContext build(QueryShardContext context) throws IOException {
        CompletionSuggestionContext suggestionContext = new CompletionSuggestionContext(context);
        // copy over common settings to each suggestion builder
        final MapperService mapperService = context.getMapperService();
        populateCommonFields(mapperService, suggestionContext);
        suggestionContext.setSkipDuplicates(skipDuplicates);
        suggestionContext.setFuzzyOptions(fuzzyOptions);
";BC_VACUOUS_INSTANCEOF
"            }
        }
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        if (!super.equals(o)) return false;
        GeoContextMapping that = (GeoContextMapping) o;
        if (precision != that.precision) return false;
";EQ_UNUSUAL
"
    /** Lower scores sorts first; if scores are equal,
     *  than later terms (zzz) sort first .*/
    @Override
    public int compareTo(Correction other) {
        return compareTo(other.score, other.candidates);
    }

    int compareTo(double otherScore, Candidate[] otherCandidates) {
        if (score == otherScore) {
            int limit = Math.min(candidates.length, otherCandidates.length);
";EQ_COMPARETO_USE_OBJECT_EQUALS
"        public boolean equals(Object obj) {
            if (this == obj) return true;
            if (obj == null) return false;
            if (getClass() != obj.getClass()) return false;
            Candidate other = (Candidate) obj;
            if (term == null) {
                if (other.term != null) return false;
            } else {
                if (!term.equals(other.term)) return false;
            }
            return true;
";EQ_UNUSUAL
"
    /**
     * this parsing method assumes that the leading ""suggest"" field name has already been parsed by the caller
     */
    public static Suggest fromXContent(XContentParser parser) throws IOException {
        ensureExpectedToken(XContentParser.Token.START_OBJECT, parser.currentToken(), parser::getTokenLocation);
        List<Suggestion<? extends Entry<? extends Option>>> suggestions = new ArrayList<>();
        while ((parser.nextToken()) != XContentParser.Token.END_OBJECT) {
            ensureExpectedToken(XContentParser.Token.FIELD_NAME, parser.currentToken(), parser::getTokenLocation);
            String currentField = parser.currentName();
            ensureExpectedToken(XContentParser.Token.START_ARRAY, parser.nextToken(), parser::getTokenLocation);
";DLS_DEAD_LOCAL_STORE
"            }
        },
        /** Suggest any matching suggest terms based on tokens in the suggest text. */
        ALWAYS {
            @Override
            public org.apache.lucene.search.spell.SuggestMode toLucene() {
              return org.apache.lucene.search.spell.SuggestMode.SUGGEST_ALWAYS;
            }
        };

        @Override
";IL_INFINITE_RECURSIVE_LOOP
"     * This method creates a SnapshotInfo from internal x-content.  It does not
     * handle x-content written with the external version as external x-content
     * is only for display purposes and does not need to be parsed.
     */
    public static SnapshotInfo fromXContentInternal(final XContentParser parser) throws IOException {
        String name = null;
        String uuid = null;
        Version version = Version.CURRENT;
        SnapshotState state = SnapshotState.IN_PROGRESS;
        String reason = null;
        List<String> indices = Collections.emptyList();
";NP_NULL_PARAM_DEREF
"    }

    // Implements equals and hashcode for testing
    @Override
    public boolean equals(Object obj) {
        if (obj == null || obj.getClass() != RawTaskStatus.class) {
            return false;
        }
        RawTaskStatus other = (RawTaskStatus) obj;
        // Totally not efficient, but ok for testing because it ignores order and spacing differences
        return toMap().equals(other.toMap());
";EQ_GETCLASS_AND_CLASS_CONSTANT
"    }

    @Override
    String formatInfo(ThreadPool.Info info) {
        return String.format(
            Locale.ROOT,
            ""name [%s], size [%d], queue size [%s]"",
            info.getName(),
            info.getMax(),
            info.getQueueSize() == null ? ""unbounded"" : info.getQueueSize());
    }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    }

    @Override
    String formatInfo(ThreadPool.Info info) {
        return String.format(
            Locale.ROOT,
            ""name [%s], size [%d], queue size [%s]"",
            info.getName(),
            info.getMax(),
            info.getQueueSize() == null ? ""unbounded"" : info.getQueueSize());
    }
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    }

    @Override
    public int compareTo(Delayed other) {
        // unwrap other by calling on it.
        return -other.compareTo(scheduledFuture);
    }

    @Override
    public boolean cancel() {
        return FutureUtils.cancel(scheduledFuture);
";RV_NEGATING_RESULT_OF_COMPARETO
"        public int hashCode() {
            return runnable.hashCode();
        }

        @Override
        public boolean equals(Object obj) {
            return runnable.equals(obj);
        }

        @Override
        public String toString() {
";EQ_UNUSUAL
"            return builder;
        }

        @Override
        public int compareTo(Stats other) {
            if ((getName() == null) && (other.getName() == null)) {
                return 0;
            } else if ((getName() != null) && (other.getName() == null)) {
                return 1;
            } else if (getName() == null) {
                return -1;
";EQ_COMPARETO_USE_OBJECT_EQUALS
"        return Tuple.tuple(host, port);
    }

    private static int parsePort(String remoteHost) {
        try {
            int port = Integer.valueOf(remoteHost.substring(indexOfPortSeparator(remoteHost) + 1));
            if (port <= 0) {
                throw new IllegalArgumentException(""port number must be > 0 but was: ["" + port + ""]"");
            }
            return port;
        } catch (NumberFormatException e) {
";DM_BOXED_PRIMITIVE_FOR_PARSING
"        }
    }

    void handleHandshake(Version version, Set<String> features, TcpChannel channel, long requestId, StreamInput stream) throws IOException {
        // Must read the handshake request to exhaust the stream
        HandshakeRequest handshakeRequest = new HandshakeRequest(stream);
        final int nextByte = stream.read();
        if (nextByte != -1) {
            throw new IllegalStateException(""Handshake request not fully read for requestId ["" + requestId + ""], action [""
                + TransportHandshaker.HANDSHAKE_ACTION_NAME + ""], available ["" + stream.available() + ""]; resetting"");
        }
";DLS_DEAD_LOCAL_STORE
"    public String toString() {
        return major + ""."" + minor + ""."" + revision;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) {
            return true;
        }
        if (o == null || getClass() != o.getClass()) {
            return false;
";EQ_UNUSUAL
"    public ResourceWatcherService.Frequency frequency() {
        return monitor.frequency;
    }

    public void stop() {
        monitor.watchers.remove(watcher);
    }

    public void resume() {
        monitor.watchers.add(watcher);
    }
";NP_UNWRITTEN_FIELD
"    /**
     * return parsed classpath, but with symlinks resolved to destination files for matching
     * this is for matching the toRealPath() in the code where we have a proper plugin structure
     */
    @SuppressForbidden(reason = ""does evil stuff with paths and urls because devs and jenkins do evil stuff with paths and urls"")
    static Set<URL> parseClassPathWithSymlinks() throws Exception {
        Set<URL> raw = JarHell.parseClassPath();
        Set<URL> cooked = new HashSet<>(raw.size());
        for (URL url : raw) {
            Path path = PathUtils.get(url.toURI());
            if (Files.exists(path)) {
";DMI_COLLECTION_OF_URLS
"    private final ClusterName clusterName;
    private volatile NodeStats[] stats = new NodeStats[3];

    /** Create a fake NodeStats for the given node and usage */
    public static NodeStats makeStats(String nodeName, DiskUsage usage) {
        FsInfo.Path[] paths = new FsInfo.Path[1];
        FsInfo.Path path = new FsInfo.Path(""/dev/null"", null,
            usage.getTotalBytes(), usage.getFreeBytes(), usage.getFreeBytes());
        paths[0] = path;
        FsInfo fsInfo = new FsInfo(System.currentTimeMillis(), null, paths);
        return new NodeStats(
";DLS_DEAD_LOCAL_STORE
"                throw new IllegalStateException(""illegal state"");
        }
    }

    public static RecoverySource randomRecoverySource() {
        return ESTestCase.randomFrom(RecoverySource.EmptyStoreRecoverySource.INSTANCE,
            RecoverySource.ExistingStoreRecoverySource.INSTANCE,
            RecoverySource.PeerRecoverySource.INSTANCE,
            RecoverySource.LocalShardsRecoverySource.INSTANCE,
            new RecoverySource.SnapshotRecoverySource(
                UUIDs.randomBase64UUID(),
";UC_USELESS_OBJECT_STACK
"            throw new IllegalStateException(""secure settings are already closed"");
        }
    }

    public SecureSettings clone() {
        ensureOpen();
        return new MockSecureSettings(this);
    }
}
null
null
";CN_IMPLEMENTS_CLONE_BUT_NOT_CLONEABLE
"    public static ESTestCase.TestAnalysis createTestAnalysisFromSettings(
            final Settings settings,
            final Path configPath,
            final AnalysisPlugin... plugins) throws IOException {
        final Settings actualSettings;
        if (settings.get(IndexMetaData.SETTING_VERSION_CREATED) == null) {
            actualSettings = Settings.builder().put(settings).put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT).build();
        } else {
            actualSettings = settings;
        }
        final IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(""test"", actualSettings);
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        DocIdSeqNoAndSource that = (DocIdSeqNoAndSource) o;
        return Objects.equals(id, that.id) && Objects.equals(source, that.source)
            && seqNo == that.seqNo && primaryTerm == that.primaryTerm && version == that.version;
    }

    @Override
    public int hashCode() {
";EQ_UNUSUAL
"        return recoveredTypes;
    }

    @Override
    public int run(Engine engine, Translog.Snapshot snapshot) throws IOException {
        int opsRecovered = 0;
        Translog.Operation operation;
        while ((operation = snapshot.next()) != null) {
            applyOperation(engine, convertToEngineOp(operation, Engine.Operation.Origin.LOCAL_TRANSLOG_RECOVERY));
            opsRecovered++;
            appliedOperations.incrementAndGet();
";NP_UNWRITTEN_FIELD
"        writeProperties(pluginDir.resolve(PluginInfo.ES_PLUGIN_PROPERTIES), stringProps);
    }

    /** convenience method to write a plugin properties file */
    private static void writeProperties(Path propertiesFile, String... stringProps) throws IOException {
        assert stringProps.length % 2 == 0;
        Files.createDirectories(propertiesFile.getParent());
        Properties properties =  new Properties();
        for (int i = 0; i < stringProps.length; i += 2) {
            properties.put(stringProps[i], stringProps[i + 1]);
        }
";NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE
"     *
     * @param randomSearchSourceBuilder builds a random {@link SearchSourceBuilder}. You can use
     *        {@link #randomSearchSourceBuilder(Supplier, Supplier, Supplier, Supplier, Supplier)}.
     */
    public static SearchRequest randomSearchRequest(Supplier<SearchSourceBuilder> randomSearchSourceBuilder) {
        SearchRequest searchRequest = new SearchRequest();
        searchRequest.allowPartialSearchResults(true);
        if (randomBoolean()) {
            searchRequest.setCcsMinimizeRoundtrips(randomBoolean());
        }
        if (randomBoolean()) {
";UC_USELESS_OBJECT
"    @Override
    public void close() throws IOException {
        attributeView.setPermissions(permissions);
    }
    public void setPermissions(Set<PosixFilePermission> newPermissions) throws IOException {
        attributeView.setPermissions(newPermissions);
    }

    public Set<PosixFilePermission> getCopyPermissions() {
        return EnumSet.copyOf(permissions);
    }
";NP_UNWRITTEN_FIELD
"        return (T)object;
    }

    @SuppressWarnings(""unchecked"")
    private Object evaluate(String key, Object object, Stash stash) throws IOException {
        if (stash.containsStashedValue(key)) {
            key = stash.getValue(key).toString();
        }

        if (object instanceof Map) {
            final Map<String, Object> objectAsMap = (Map<String, Object>) object;
";DM_BOXED_PRIMITIVE_FOR_PARSING
"        }
        return restSpec;
    }

    private static void parseSpecFile(ClientYamlSuiteRestApiParser restApiParser, Path jsonFile, ClientYamlSuiteRestSpec restSpec) {
        try (InputStream stream = Files.newInputStream(jsonFile)) {
            try (XContentParser parser =
                     JsonXContent.jsonXContent.createParser(NamedXContentRegistry.EMPTY, LoggingDeprecationHandler.INSTANCE, stream)) {
                String filename = jsonFile.getFileName().toString();
                if (filename.equals(""_common.json"")) {
                    String currentFieldName = null;
";NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE
" * Holds a REST test suite loaded from a specific yaml file.
 * Supports a setup section and multiple test sections.
 */
public class ClientYamlTestSuite {
    public static ClientYamlTestSuite parse(NamedXContentRegistry executeableSectionRegistry, String api, Path file) throws IOException {
        if (!Files.isRegularFile(file)) {
            throw new IllegalArgumentException(file.toAbsolutePath() + "" is not a file"");
        }

        String filename = file.getFileName().toString();
        //remove the file extension
";NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE
"            rhs.select(nodes);
            lhs.select(nodes);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
";EQ_UNUSUAL
"        Setting.doubleSetting(""index.store.mock.random.io_exception_rate"", 0.0d,  0.0d, Property.IndexScope, Property.NodeScope);
    public static final Setting<Boolean> CRASH_INDEX_SETTING =
        Setting.boolSetting(""index.store.mock.random.crash_index"", true, Property.IndexScope, Property.NodeScope);

    @Override
    public Directory newDirectory(IndexSettings idxSettings, ShardPath path) throws IOException {
        Settings indexSettings = idxSettings.getSettings();
        Random random = new Random(idxSettings.getValue(ESIntegTestCase.INDEX_TEST_SEED_SETTING));
        return wrap(randomDirectoryService(random, idxSettings, path), random, indexSettings,
            path.getShardId());
    }
";IL_INFINITE_RECURSIVE_LOOP
"    private static final class Listener implements IndexEventListener {

        private final Map<IndexShard, Boolean> shardSet = Collections.synchronizedMap(new IdentityHashMap<>());
        @Override
        public void afterIndexShardClosed(ShardId shardId, @Nullable IndexShard indexShard, Settings indexSettings) {
            if (indexShard != null) {
                Boolean remove = shardSet.remove(indexShard);
                if (remove == Boolean.TRUE) {
                    Logger logger = Loggers.getLogger(getClass(), indexShard.shardId());
                    MockFSDirectoryFactory.checkIndex(logger, indexShard.store(), indexShard.shardId());
                }
";RC_REF_COMPARISON_BAD_PRACTICE_BOOLEAN
"    private static final DateFormatter dateTimeFormatter = DateFormatter.forPattern(""strict_date_time"").withZone(ZoneOffset.UTC);

    public static long endOfTheDay(String date) {
        try {
            // Try parsing using complete date/time format
            return dateTimeFormatter.parseMillis(date);
        } catch (ElasticsearchParseException | IllegalArgumentException ex) {
            ZonedDateTime dateTime = DateFormatters.from(dateOnlyFormatter.parse(date));
            dateTime.with(ChronoField.MILLI_OF_DAY, ChronoField.MILLI_OF_DAY.range().getMaximum());
            return dateTime.toInstant().toEpochMilli();
        }
";RV_RETURN_VALUE_IGNORED_INFERRED
"    }

    @Override
    protected void masterOperation(Task task, GetBasicStatusRequest request, ClusterState state,
                                   ActionListener<GetBasicStatusResponse> listener) throws Exception {
        LicensesMetaData licensesMetaData = state.metaData().custom(LicensesMetaData.TYPE);
        if (licensesMetaData == null) {
            listener.onResponse(new GetBasicStatusResponse(true));
        } else {
            License license = licensesMetaData.getLicense();
            listener.onResponse(new GetBasicStatusResponse(license == null || license.type().equals(""basic"") == false));
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"     * @deprecated Types are in the process of being removed. Instead of using a type, prefer to
     * filter on a field on the document.
     */
    @Deprecated
    public String[] types() {
        return this.types;
    }

    /**
     * The document types to execute the explore request against. Defaults to be executed against
     * all types.
";EI_EXPOSE_REP
"    static final String RETURN_DETAILED_INFO_PARAM = ""returnDetailedInfo"";

    public GraphExploreResponse() {
    }

    public GraphExploreResponse(long tookInMillis, boolean timedOut, ShardOperationFailedException[] shardFailures,
                                Map<VertexId, Vertex> vertices, Map<ConnectionId, Connection> connections, boolean returnDetailedInfo) {
        this.tookInMillis = tookInMillis;
        this.timedOut = timedOut;
        this.shardFailures = shardFailures;
        this.vertices = vertices;
";EI_EXPOSE_REP2
"        indicesOptions.writeIndicesOptions(out);
    }

    @Override
    public String[] indices() {
        return indices;
    }

    @Override
    public IndexUpgradeInfoRequest indices(String... indices) {
        this.indices = Objects.requireNonNull(indices, ""indices cannot be null"");
";EI_EXPOSE_REP
"        ReloadAnalyzersRequest that = (ReloadAnalyzersRequest) o;
        return Objects.equals(indicesOptions(), that.indicesOptions())
                && Arrays.equals(indices, that.indices);
    }

    @Override
    public int hashCode() {
        return Objects.hash(indicesOptions(), Arrays.hashCode(indices));
    }

}
";EI_EXPOSE_REP2
"        /**
         * @return the indices to be frozen or unfrozen
         */
        @Override
        public String[] indices() {
            return indices;
        }

        /**
         * Specifies what type of requested indices to ignore and how to deal with wildcard expressions.
         * For example indices that don't exist.
";EI_EXPOSE_REP
"
        public Request() {
        }

        public String[] getFollowerIndices() {
            return followerIndices;
        }

        public void setFollowerIndices(String... followerIndices) {
            this.followerIndices = followerIndices;
        }
";EI_EXPOSE_REP
"            READ_POLL_TIMEOUT, ObjectParser.ValueType.STRING);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o instanceof FollowParameters == false) return false;
        FollowParameters that = (FollowParameters) o;
        return Objects.equals(maxReadRequestOperationCount, that.maxReadRequestOperationCount) &&
            Objects.equals(maxWriteRequestOperationCount, that.maxWriteRequestOperationCount) &&
            Objects.equals(maxOutstandingReadRequests, that.maxOutstandingReadRequests) &&
";EQ_DOESNT_OVERRIDE_EQUALS
"        public String[] indices() {
            return indices;
        }

        public void setIndices(final String[] indices) {
            this.indices = indices;
        }

        @Override
        public IndicesOptions indicesOptions() {
            return IndicesOptions.strictExpand();
";EI_EXPOSE_REP2
"    public static final String READ_EXCEPTIONS_ENTRY_PARSER_NAME = ""shard-follow-node-task-status-read-exceptions-entry"";

    static final ConstructingObjectParser<Map.Entry<Long, Tuple<Integer, ElasticsearchException>>, Void> READ_EXCEPTIONS_ENTRY_PARSER =
            new ConstructingObjectParser<>(
                READ_EXCEPTIONS_ENTRY_PARSER_NAME,
                    args -> new AbstractMap.SimpleEntry<>((long) args[0], Tuple.tuple((Integer)args[1], (ElasticsearchException)args[2])));

    static {
        STATUS_PARSER.declareString(ConstructingObjectParser.constructorArg(), LEADER_CLUSTER);
        STATUS_PARSER.declareString(ConstructingObjectParser.constructorArg(), LEADER_INDEX);
        STATUS_PARSER.declareString(ConstructingObjectParser.constructorArg(), FOLLOWER_INDEX);
";BX_UNBOXING_IMMEDIATELY_REBOXED
"            builder.endObject();
            return builder;
        }

        @Override
        public boolean equals(Object obj) {
            if (obj == this) {
                return true;
            }

            if (obj == null || obj.getClass() != getClass()) {
";EQ_UNUSUAL
"                                   @Nullable String reason,
                                   @Nullable DataFrameTransformProgress progress) {
        this(taskState, indexerState, position, checkpoint, reason, progress, null);
    }

    public DataFrameTransformState(StreamInput in) throws IOException {
        taskState = DataFrameTransformTaskState.fromStream(in);
        indexerState = IndexerState.fromStream(in);
        Map<String, Object> position = in.readMap();
        currentPosition = position == null ? null : Collections.unmodifiableMap(position);
        checkpoint = in.readLong();
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"        this.queryConfig = ExceptionsHelper.requireNonNull(queryConfig, QUERY.getPreferredName());
    }

    public SourceConfig(final StreamInput in) throws IOException {
        index = in.readStringArray();
        queryConfig = new QueryConfig(in);
    }

    public String[] getIndex() {
        return index;
    }
";EI_EXPOSE_REP
"
                    return parser;
                }

    public TimeSyncConfig() {
        this(null, null);
    }

    public TimeSyncConfig(final String field, final TimeValue delay) {
        this.field = ExceptionsHelper.requireNonNull(field, DataFrameField.FIELD.getPreferredName());
        this.delay = ExceptionsHelper.requireNonNull(delay, DataFrameField.DELAY.getPreferredName());
";NP_NULL_PARAM_DEREF_NONVIRTUAL
"null
null
null
null
null
null
null
null
null
null
null
";EQ_UNUSUAL
"            out.writeStringArray(indices);
        }

        @Override
        public String[] indices() {
            return indices;
        }

        @Override
        public Request indices(String... indices) {
            this.indices = indices;
";EI_EXPOSE_REP
"        public Request() {
            policyNames = Strings.EMPTY_ARRAY;
        }

        public String[] getPolicyNames() {
            return policyNames;
        }

        @Override
        public ActionRequestValidationException validate() {
            return null;
";EI_EXPOSE_REP
"            return this;
        }

        @Override
        public String[] indices() {
            return indices;
        }

        public void indicesOptions(IndicesOptions indicesOptions) {
            this.indicesOptions = indicesOptions;
        }
";EI_EXPOSE_REP
"            return this;
        }

        @Override
        public String[] indices() {
            return indices;
        }

        @Override
        public IndicesOptions indicesOptions() {
            return indicesOptions;
";EI_EXPOSE_REP
"        return true;
    }

    @Override
    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {
        StepKey allocateKey = new StepKey(phase, NAME, NAME);
        StepKey allocationRoutedKey = new StepKey(phase, NAME, AllocationRoutedStep.NAME);

        Settings.Builder newSettings = Settings.builder();
        if (numberOfReplicas != null) {
            newSettings.put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, numberOfReplicas);
";DLS_DEAD_LOCAL_STORE
"    }

    @Override
    public boolean equals(Object obj) {
        if (obj == null) {
            return false;
        }
        if (obj.getClass() != getClass()) {
            return false;
        }
        ExplainLifecycleRequest other = (ExplainLifecycleRequest) obj;
";EI_EXPOSE_REP
"
    public static final class PhaseStats implements ToXContentObject, Writeable {
        private final String[] actionNames;
        private final TimeValue minimumAge;

        public PhaseStats(TimeValue after, String[] actionNames) {
            this.actionNames = actionNames;
            this.minimumAge = after;
        }

        public PhaseStats(StreamInput in) throws IOException {
";EI_EXPOSE_REP2
"        return true;
    }

    @Override
    public List<Step> toSteps(Client client, String phase, Step.StepKey nextStepKey) {
        Step.StepKey key = new Step.StepKey(phase, NAME, NAME);
        Settings readOnlySettings = Settings.builder().put(IndexMetaData.SETTING_BLOCKS_WRITE, true).build();
        return Collections.singletonList(new UpdateSettingsStep(key, nextStepKey, client, readOnlySettings));
    }

    @Override
";DLS_DEAD_LOCAL_STORE
"        return true;
    }

    @Override
    public List<Step> toSteps(Client client, String phase, StepKey nextStepKey) {
        StepKey key = new StepKey(phase, NAME, NAME);
        Settings indexPriority = recoveryPriority == null ?
            Settings.builder().putNull(IndexMetaData.INDEX_PRIORITY_SETTING.getKey()).build()
            : Settings.builder().put(IndexMetaData.INDEX_PRIORITY_SETTING.getKey(), recoveryPriority).build();
        return Collections.singletonList(new UpdateSettingsStep(key, nextStepKey, client, indexPriority));
    }
";DLS_DEAD_LOCAL_STORE
"        }

        public String[] getOpenJobIds() { return openJobIds; }

        public void setOpenJobIds(String [] openJobIds) {
            this.openJobIds = openJobIds;
        }

        @Override
        public boolean match(Task task) {
            for (String id : openJobIds) {
";EI_EXPOSE_REP2
"
        public Request() {
        }

        public String[] getIndices() {
            return indices;
        }

        public final void setIndices(List<String> indices) {
            ExceptionsHelper.requireNonNull(indices, INDEX);
            if (indices.isEmpty()) {
";EI_EXPOSE_REP
"
    public static class Request extends MasterNodeRequest<Request> {

        private String[] jobIds;

        public Request(String[] jobIds) {
            this.jobIds = jobIds;
        }

        public Request() {
        }
";EI_EXPOSE_REP2
"
        private boolean flushed;
        private Date lastFinalizedBucketEnd;

        public Response(boolean flushed, @Nullable Date lastFinalizedBucketEnd) {
            super(null, null);
            this.flushed = flushed;
            this.lastFinalizedBucketEnd = lastFinalizedBucketEnd;
        }

        public Response(StreamInput in) throws IOException {
";EI_EXPOSE_REP2
"        public String[] getResolvedStartedDatafeedIds() {
            return resolvedStartedDatafeedIds;
        }

        public void setResolvedStartedDatafeedIds(String[] resolvedStartedDatafeedIds) {
            this.resolvedStartedDatafeedIds = resolvedStartedDatafeedIds;
        }

        public TimeValue getStopTimeout() {
            return stopTimeout;
        }
";EI_EXPOSE_REP2
"                    ""unexpected token ["" + p.currentToken() + ""] for ["" + END_TIME.getPreferredName() + ""]"");
        }, END_TIME, ObjectParser.ValueType.VALUE);

        parser.declareString(ScheduledEvent.Builder::calendarId, Calendar.ID);
        parser.declareString((builder, s) -> {}, TYPE);

        return parser;
    }

    public static String documentId(String eventId) {
        return DOCUMENT_ID_PREFIX + eventId;
";EI_EXPOSE_REP
"     * The lists of indices and types are compared for equality but they are not
     * sorted first so this test could fail simply because the indices and types
     * lists are in different orders.
     */
    @Override
    public boolean equals(Object other) {
        if (this == other) {
            return true;
        }

        if (other instanceof DatafeedConfig == false) {
";EQ_UNUSUAL
"
    public DataFrameAnalyticsSource(StreamInput in) throws IOException {
        index = in.readStringArray();
        queryProvider = QueryProvider.fromStream(in);
    }

    public DataFrameAnalyticsSource(DataFrameAnalyticsSource other) {
        this.index = Arrays.copyOf(other.index, other.index.length);
        this.queryProvider = new QueryProvider(other.queryProvider);
    }

";EI_EXPOSE_REP
"            this.threshold = in.readDouble();
        }

        @Override
        public int compareTo(AucRocPoint o) {
            return Comparator.comparingDouble((AucRocPoint p) -> p.threshold).reversed()
                .thenComparing(p -> p.fpr)
                .thenComparing(p -> p.tpr)
                .compare(this, o);
        }

";EQ_COMPARETO_USE_OBJECT_EQUALS
"        private final long[] tp;
        private final long[] fp;
        private final long[] tn;
        private final long[] fn;

        public Result(double[] thresholds, long[] tp, long[] fp, long[] tn, long[] fn) {
            assert thresholds.length == tp.length;
            assert thresholds.length == fp.length;
            assert thresholds.length == tn.length;
            assert thresholds.length == fn.length;
            this.thresholds = thresholds;
";EI_EXPOSE_REP2
"
    private final String name;
    private final double[] thresholds;
    private final double[] scores;

    public ScoreByThresholdResult(String name, double[] thresholds, double[] scores) {
        assert thresholds.length == scores.length;
        this.name = Objects.requireNonNull(name);
        this.thresholds = thresholds;
        this.scores = scores;
    }
";EI_EXPOSE_REP2
"            this.createTime = createTime;
            return this;
        }

        public Builder setFinishedTime(Date finishedTime) {
            this.finishedTime = finishedTime;
            return this;
        }

        public Builder setDataDescription(DataDescription.Builder description) {
            dataDescription = ExceptionsHelper.requireNonNull(description, DATA_DESCRIPTION.getPreferredName()).build();
";EI_EXPOSE_REP2
"    private long processedFieldCount;
    private long inputBytes;
    private long inputFieldCount;
    private long invalidDateCount;
    private long missingFieldCount;
    private long outOfOrderTimeStampCount;
    private long emptyBucketCount;
    private long sparseBucketCount;
    private long bucketCount;
    // TODO: Use java.time for the Dates here: x-pack-elasticsearch#829
    private Date earliestRecordTimeStamp;
";EI_EXPOSE_REP2
"        private long bucketAllocationFailuresCount;
        private MemoryStatus memoryStatus;
        private Date timestamp;
        private Date logTime;

        public Builder(String jobId) {
            this.jobId = jobId;
            memoryStatus = MemoryStatus.OK;
            logTime = new Date();
        }

";EI_EXPOSE_REP2
"            this.minVersion = Version.fromString(minVersion);
            return this;
        }

        public Builder setTimestamp(Date timestamp) {
            this.timestamp = timestamp;
            return this;
        }

        public Builder setDescription(String description) {
            this.description = description;
";EI_EXPOSE_REP2
"
    public static String documentId(String jobId) {
        return jobId + ""_"" + TYPE;
    }

    /**
     * This is how the IDs were formed in v5.4
     */
    public static String v54DocumentId(String jobId) {
        return jobId + ""-"" + TYPE;
    }
";EI_EXPOSE_REP2
"        builder.endObject();
        return builder;
    }

    XContentBuilder innerToXContent(XContentBuilder builder, Params params) throws IOException {
        builder.field(Job.ID.getPreferredName(), jobId);
        builder.field(Result.RESULT_TYPE.getPreferredName(), RESULT_TYPE_VALUE);
        builder.field(PROBABILITY.getPreferredName(), probability);
        if (multiBucketImpact != null) {
            builder.field(MULTI_BUCKET_IMPACT.getPreferredName(), multiBucketImpact);
        }
";WMI_WRONG_MAP_ITERATOR
"    public long getEpoch() {
        return timestamp.getTime() / 1000;
    }

    public Date getTimestamp() {
        return timestamp;
    }

    /**
     * Bucketspan expressed in seconds
     */
";EI_EXPOSE_REP
"    public String getInfluencerFieldName() {
        return influenceField;
    }

    public void setInfluencerFieldName(String fieldName) {
        this.influenceField = fieldName;
    }

    public double getInitialAnomalyScore() {
        return initialAnomalyScore;
    }
";EI_EXPOSE_REP
"    public void setProbability(double probability) {
        this.probability = probability;
    }

    public Date getTimestamp() {
        return timestamp;
    }

    public String getInfluencerFieldName() {
        return influenceField;
    }
";EI_EXPOSE_REP
"        builder.endObject();
        return builder;
    }

    public Date getTimestamp() {
        return timestamp;
    }

    /**
     * Bucketspan expressed in seconds
     */
";EI_EXPOSE_REP
"null
null
null
null
null
null
null
null
null
null
null
";EQ_UNUSUAL
"        if (fields == null || fields.length == 0) {
            throw new IllegalArgumentException(""Fields must have at least one value"");
        }
        this.interval = interval;
        this.fields = fields;
    }

    HistogramGroupConfig(final StreamInput in) throws IOException {
        interval = in.readVLong();
        fields = in.readStringArray();
    }
";EI_EXPOSE_REP2
"        }
        if (indexPattern.equals(rollupIndex)) {
            throw new IllegalArgumentException(""Rollup index may not be the same as the index pattern"");
        }
        if (rollupIndex == null || rollupIndex.isEmpty()) {
            throw new IllegalArgumentException(""Rollup index must be a non-null, non-empty string"");
        }
        if (cron == null || cron.isEmpty()) {
            throw new IllegalArgumentException(""Cron schedule must be a non-null, non-empty string"");
        }
        if (pageSize <= 0) {
";RCN_REDUNDANT_NULLCHECK_OF_NONNULL_VALUE
"                                 ActionRequestValidationException validationException) {

        Arrays.stream(fields).forEach(field -> {
            Map<String, FieldCapabilities> fieldCaps = fieldCapsResponse.get(field);
            if (fieldCaps != null && fieldCaps.isEmpty() == false) {
                fieldCaps.forEach((key, value) -> {
                    if (key.equals(KeywordFieldMapper.CONTENT_TYPE) || key.equals(TextFieldMapper.CONTENT_TYPE)) {
                        if (value.isAggregatable() == false) {
                            validationException.addValidationError(""The field ["" + field + ""] must be aggregatable across all indices, "" +
                                    ""but is not."");
                        }
";EI_EXPOSE_REP
"    public static GetApiKeyResponse emptyResponse() {
        return new GetApiKeyResponse(Collections.emptyList());
    }

    public ApiKey[] getApiKeyInfos() {
        return foundApiKeysInfo;
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject()
";EI_EXPOSE_REP
"    public RefreshPolicy getRefreshPolicy() {
        return refreshPolicy;
    }

    @Override
    public ActionRequestValidationException validate() {
        ActionRequestValidationException validationException = null;
        if (Strings.isNullOrEmpty(application)) {
            validationException = addValidationError(""application name is missing"", validationException);
        }
        if (privileges == null || privileges.length == 0 || Arrays.stream(privileges).allMatch(Strings::isNullOrEmpty)) {
";EI_EXPOSE_REP2
"
    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeOptionalString(application);
        out.writeStringArray(privileges);
    }
}
null
null
null
";EI_EXPOSE_REP
"null
null
null
null
null
null
null
null
null
null
null
";WMI_WRONG_MAP_ITERATOR
"        super.readFrom(in);
        names = in.readOptionalStringArray();
    }

    @Override
    public void writeTo(StreamOutput out) throws IOException {
        super.writeTo(out);
        out.writeOptionalStringArray(names);
    }

    public static class Node extends BaseNodeRequest {
";EI_EXPOSE_REP
"    public GetRolesResponse(RoleDescriptor... roles) {
        this.roles = roles;
    }

    public RoleDescriptor[] roles() {
        return roles;
    }

    public boolean hasRoles() {
        return roles.length > 0;
    }
";EI_EXPOSE_REP
"    public GetRoleMappingsResponse(ExpressionRoleMapping... mappings) {
        this.mappings = mappings;
    }

    public ExpressionRoleMapping[] mappings() {
        return mappings;
    }

    public boolean hasMappings() {
        return mappings.length > 0;
    }
";EI_EXPOSE_REP
"            if (grantType != null) {
                for (GrantType type : values()) {
                    if (type.getValue().equals(grantType)) {
                        return type;
                    }
                }
            }
            return null;
        }
    }

";EI_EXPOSE_REP2
"    }

    public void passwordHash(char[] passwordHash) {
        this.passwordHash = passwordHash;
    }

    /**
     * Should this request trigger a refresh ({@linkplain RefreshPolicy#IMMEDIATE}, the default), wait for a refresh (
     * {@linkplain RefreshPolicy#WAIT_UNTIL}), or proceed ignore refreshes entirely ({@linkplain RefreshPolicy#NONE}).
     */
    @Override
";EI_EXPOSE_REP
"    public GetUsersResponse(Collection<User> users) {
        this(users.toArray(new User[users.size()]));
    }

    public User[] users() {
        return users;
    }

    public boolean hasUsers() {
        return users != null && users.length > 0;
    }
";EI_EXPOSE_REP
"    public String[] usernames() {
        return new String[] { username };
    }

    public RoleDescriptor.IndicesPrivileges[] indexPrivileges() {
        return indexPrivileges;
    }

    public String[] clusterPrivileges() {
        return clusterPrivileges;
    }
";EI_EXPOSE_REP
"            + ""}"";
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject()
            .field(""username"", username)
            .field(""has_all_requested"", completeMatch);

        builder.field(""cluster"");
        builder.map(cluster);
";WMI_WRONG_MAP_ITERATOR
"    public char[] passwordHash() {
        return passwordHash;
    }

    public boolean enabled() {
        return enabled;
    }

    @Override
    public String[] usernames() {
        return new String[] { username };
";EI_EXPOSE_REP
"        public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
            return builder.value(value);
        }

        @Override
        public boolean equals(Object o) {
            if (this == o) {
                return true;
            }
            if (o == null || getClass() != o.getClass()) {
                return false;
";EQ_UNUSUAL
"
    public byte[] getCurrentKeyHash() {
        return currentKeyHash;
    }

    public TokenMetaData(List<KeyAndTimestamp> keys, byte[] currentKeyHash) {
        this.keys = keys;
        this.currentKeyHash = currentKeyHash;
    }

    public TokenMetaData(StreamInput input) throws IOException {
";EI_EXPOSE_REP2
"    public Predicate<String> predicate() {
        return predicate;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Privilege privilege = (Privilege) o;

";EQ_UNUSUAL
"        private boolean hasDeniedFields() {
            return deniedFields != null && deniedFields.length > 0;
        }

        private boolean hasGrantedFields() {
            if (grantedFields != null && grantedFields.length >= 0) {
                // we treat just '*' as no FLS since that's what the UI defaults to
                if (grantedFields.length == 1 && ""*"".equals(grantedFields[0])) {
                    return false;
                } else {
                    return true;
";INT_BAD_COMPARISON_WITH_NONNEGATIVE_VALUE
"    public int hashCode() {
        return Objects.hash(ackStatus, lastExecution, lastSuccessfulExecution, lastThrottle);
    }

    public void update(ZonedDateTime timestamp, Action.Result result) {
        switch (result.status()) {

            case FAILURE:
                String reason = result instanceof Action.Result.Failure ? ((Action.Result.Failure) result).reason() : """";
                lastExecution = Execution.failure(timestamp, reason);
                return;
";SF_SWITCH_NO_DEFAULT
"        builder.timeField(""triggered_time"", triggeredTime);
        builder.timeField(""execution_time"", executionTime);
        builder.endObject();
        return builder;
    }

}
null
null
null
null
";EQ_UNUSUAL
"            out.writeString(element.getMethodName());
            out.writeOptionalString(element.getFileName());
            out.writeInt(element.getLineNumber());
        }
    }

    @Override
    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {
        builder.startObject();
        builder.field(""watch_id"", watchId);
        builder.field(""watch_record_id"", watchRecordId);
";EQ_UNUSUAL
"        ActionRequestValidationException validationException = null;
        if (watchId == null){
            validationException = ValidateActions.addValidationError(""watch id is missing"", validationException);
        } else if (WatcherUtils.isValidId(watchId) == false) {
            validationException = ValidateActions.addValidationError(""watch id contains whitespace"", validationException);
        }
        if (actionIds != null) {
            for (String actionId : actionIds) {
                if (actionId == null) {
                    validationException = ValidateActions.addValidationError(
                            String.format(Locale.ROOT, ""action id may not be null""), validationException);
";EI_EXPOSE_REP
"        return Objects.hash(manuallyStopped);
    }

    public static MetaData.Custom fromXContent(XContentParser parser) throws IOException {
        XContentParser.Token token;
        Boolean manuallyStopped = null;
        String currentFieldName = null;
        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {
            switch (token) {
                case FIELD_NAME:
                    currentFieldName = parser.currentName();
";SF_SWITCH_NO_DEFAULT
"        this.settings = settings;
    }

    @Override
    public List<Setting<?>> getSettings() {
        ArrayList<Setting<?>> settings = new ArrayList<>();
        // the only licensing one
        settings.add(Setting.groupSetting(""license."", Setting.Property.NodeScope));

        //TODO split these settings up
        settings.addAll(XPackSettings.getAllSettings());
";UC_USELESS_OBJECT
"                if (Strings.hasLength(failedStep) == false) {
                    failedStep = randomAlphaOfLength(10);
                } else if (randomBoolean()) {
                    failedStep = failedStep + randomAlphaOfLengthBetween(1, 5);
                } else {
                    failedStep = null;
                }
                break;
            case 7:
                policyTime = randomValueOtherThan(policyTime, () -> randomLongBetween(0, 100000));
                break;
";EQ_UNUSUAL
"import org.elasticsearch.xpack.core.ssl.action.GetCertificateInfoAction;
import org.elasticsearch.xpack.core.ssl.action.TransportGetCertificateInfoAction;
import org.elasticsearch.xpack.core.ssl.rest.RestGetCertificateInfoAction;
import org.elasticsearch.xpack.security.action.TransportCreateApiKeyAction;
import org.elasticsearch.xpack.security.action.TransportGetApiKeyAction;
import org.elasticsearch.xpack.security.action.TransportInvalidateApiKeyAction;
import org.elasticsearch.xpack.security.action.filter.SecurityActionFilter;
import org.elasticsearch.xpack.security.action.oidc.TransportOpenIdConnectAuthenticateAction;
import org.elasticsearch.xpack.security.action.oidc.TransportOpenIdConnectLogoutAction;
import org.elasticsearch.xpack.security.action.oidc.TransportOpenIdConnectPrepareAuthenticationAction;
import org.elasticsearch.xpack.security.action.privilege.TransportDeletePrivilegesAction;
";NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE
"null
null
null
null
null
null
null
null
null
null
null
";EQ_UNUSUAL
"            }
            else {
                // use the initial value
                next = child;
            }
            transformedChildren.add(next);
        }

        return (childrenChanged ? replaceChildren(transformedChildren) : (T) this);
    }

";EQ_UNUSUAL
"null
null
null
null
null
null
null
null
null
null
null
";ICAST_INT_CAST_TO_DOUBLE_PASSED_TO_CEIL
"import java.time.ZoneId;
import java.time.ZonedDateTime;
import java.time.format.DateTimeFormatter;
import java.time.format.DateTimeFormatterBuilder;

import static java.time.format.DateTimeFormatter.ISO_LOCAL_DATE;
import static java.time.format.DateTimeFormatter.ISO_LOCAL_TIME;
import static java.time.format.DateTimeFormatter.ISO_TIME;

public final class DateUtils {

";RV_RETURN_VALUE_IGNORED_INFERRED
"null
null
null
null
null
null
null
null
null
null
null
";SF_SWITCH_NO_DEFAULT
